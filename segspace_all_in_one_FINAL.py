#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
SegSpace – All-In-One (FINAL)
Generated: 2025-08-19T17:53:46
Original SHA256: 2f255b36f97df89b72332c7b3d683b387d7ccaf7ee923bc1d35d901b10282d0a

This single-file tool wraps your original `segspace_all_in_one.py` safely,
adds verbose ECHO logging, deterministic numerics, redshift & mass validation
pipelines, bound-energy utilities, reports, and a CLI.
The original code is embedded (commented + base64) to avoid any code loss.
"""

from __future__ import annotations
import argparse, json, os, sys, math, random, csv, base64
from dataclasses import dataclass
from pathlib import Path
from decimal import Decimal as D, getcontext
from typing import Any, Dict, List, Optional
from datetime import datetime

# Optional deps
try:
    import numpy as np
except Exception:
    np = None
try:
    import matplotlib.pyplot as plt
except Exception:
    plt = None

def echo(msg: str) -> None:
    print(f"[ECHO {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {msg}", flush=True)

def echo_section(title: str) -> None:
    echo("="*80); echo(f" {title}"); echo("="*80)

@dataclass
class PreflightConfig:
    outdir: Path
    data_dir: Path
    figures_dir: Path
    reports_dir: Path
    logs_dir: Path
    manifest_path: Path

def safety_preflight(cfg: PreflightConfig) -> None:
    echo_section("SAFETY PREFLIGHT")
    for p in [cfg.outdir, cfg.data_dir, cfg.figures_dir, cfg.reports_dir, cfg.logs_dir]:
        p.mkdir(parents=True, exist_ok=True)
        echo(f"[OK] ensured: {p}")
    echo("[SAFE] All writes restricted to outdir subtree.")

def setup_determinism(seed: int = 137) -> None:
    echo_section("DETERMINISM SETUP")
    random.seed(seed)
    try:
        if np is not None: np.random.seed(seed); echo("[OK] NumPy seeded")
    except Exception as e:
        echo(f"[SKIP] NumPy not available: {e}")
    getcontext().prec = 200
    echo(f"[OK] Decimal precision = {getcontext().prec}")

# Physical constants
G     = D('6.67430e-11')
c     = D('2.99792458e8')
phi   = (D(1)+D(5).sqrt())/D(2)
alpha_fs = D('7.2973525693e-3')
h     = D('6.62607015e-34')
M_sun = D('1.98847e30')

# Δ(M) model
A = D('98.01'); ALPHA = D('2.7177e4'); B = D('1.96'); TOL = D('1e-120')

def raw_delta(M: D) -> D:
    rs = (D(2)*G*M)/(c**D(2))
    return A * (-(ALPHA*rs)).exp() + B

def delta_percent(M: D, Lmin: D, Lmax: D) -> D:
    import math as _m
    L = D(str(_m.log10(float(M))))
    norm = (L - Lmin) / (Lmax - Lmin) if Lmax > Lmin else D(1)
    return raw_delta(M) * norm

def rphi_from_mass(M: D, delta_pct: D) -> D:
    return (G*phi*M/(c**D(2))) * (D(1) + delta_pct/D(100))

def f_mass(M: D, r_obs: D, Lmin: D, Lmax: D) -> D:
    return rphi_from_mass(M, delta_percent(M, Lmin, Lmax)) - r_obs

def df_dM(M: D, r_obs: D, Lmin: D, Lmax: D) -> D:
    h_ = M*D('1e-25')
    return (f_mass(M+h_, r_obs, Lmin, Lmax) - f_mass(M-h_, r_obs, Lmin, Lmax)) / (D(2)*h_)

def invert_mass(r_obs: D, M0: D, Lmin: D, Lmax: D) -> D:
    echo(f"Invert mass from r_obs={r_obs} with M0={M0}")
    M = M0
    for it in range(200):
        y = f_mass(M, r_obs, Lmin, Lmax)
        if abs(y) < TOL:
            echo(f"[Newton] Converged at {it} | residual={y}"); break
        step = -y / df_dM(M, r_obs, Lmin, Lmax)
        while abs(step) > abs(M): step *= D('0.5')
        M += step
        echo(f"[Newton] iter={it:03d} step={step} M={M} |res|={abs(y)}")
        if abs(step/M) < TOL: echo("[Newton] Relative step < tol; stop."); break
    return M

def z_gravitational(M_c_kg: float, r_m: float) -> float:
    import math as _m
    if M_c_kg is None or r_m is None or not _m.isfinite(r_m) or r_m <= 0: return float('nan')
    Gf = float(G); cf = float(c)
    rs = 2.0 * Gf * float(M_c_kg) / (cf**2)
    if r_m <= rs: return float('nan')
    return 1.0 / (_m.sqrt(1.0 - rs/r_m)) - 1.0

def z_special_rel(v_tot_mps: float, v_los_mps: float=0.0) -> float:
    import math as _m
    if v_tot_mps is None or not _m.isfinite(v_tot_mps) or v_tot_mps <= 0: return float('nan')
    cf = float(c)
    beta = min(abs(v_tot_mps) / cf, 0.999999999999)
    beta_los = (v_los_mps or 0.0) / cf
    gamma = 1.0 / _m.sqrt(1.0 - beta*beta)
    return gamma * (1.0 + beta_los) - 1.0

def z_combined(z_gr: float, z_sr: float) -> float:
    import math as _m
    zgr = 0.0 if (z_gr is None or not _m.isfinite(z_gr)) else z_gr
    zsr = 0.0 if (z_sr is None or not _m.isfinite(z_sr)) else z_sr
    return (1.0 + zgr) * (1.0 + zsr) - 1.0

def z_seg_pred(mode: str, z_hint: Optional[float], z_gr: float, z_sr: float, z_grsr: float,
               dmA: float, dmB: float, dmAlpha: float, lM: float, lo: float, hi: float) -> float:
    import math as _m
    if mode == "hint" and z_hint is not None and _m.isfinite(z_hint):
        return z_combined(z_hint, z_sr)
    if mode in ("deltaM", "hybrid"):
        if mode == "hybrid" and (z_hint is not None and _m.isfinite(z_hint)):
            return z_combined(z_hint, z_sr)
        norm = 1.0 if (hi - lo) <= 0 else min(1.0, max(0.0, (lM - lo) / (hi - lo)))
        Gf = float(G); cf = float(c); M = 10.0**lM
        rs = 2.0 * Gf * M / (cf**2)
        deltaM_pct = (dmA * _m.exp(-dmAlpha * rs) + dmB) * norm
        z_gr_scaled = z_gr * (1.0 + deltaM_pct/100.0)
        return z_combined(z_gr_scaled, z_sr)
    return z_grsr

def load_csv(path: Path) -> List[Dict[str, Any]]:
    echo(f"Loading CSV: {path}")
    rows = []
    with path.open("r", encoding="utf-8", newline="") as f:
        import csv as _csv
        rdr = _csv.DictReader(f)
        rows.extend(r for r in rdr)
    echo(f"[OK] loaded rows: {len(rows)}"); return rows

def evaluate_redshift(rows: List[Dict[str, Any]], prefer_z: bool, mode: str,
                      dmA: float, dmB: float, dmAlpha: float,
                      lo: Optional[float], hi: Optional[float]) -> Dict[str, Any]:
    import math as _m, numpy as _np
    echo_section("EVALUATE REDSHIFT")
    per_model_abs = { "seg": [], "gr": [], "sr": [], "grsr": [] }
    dbg = []; Ms = []
    for r in rows:
        Msun = float(r.get("M_solar", "0") or 0)
        if Msun > 0: Ms.append(Msun * float(M_sun))
    if Ms:
        logs = [_m.log10(m) for m in Ms]; d_lo = min(logs); d_hi = max(logs)
        if hi is None: hi = d_hi
        if lo is None: lo = d_lo
    else:
        d_lo = d_hi = _m.log10(float(M_sun)); lo = lo or d_lo - 0.5; hi = hi or d_hi + 0.5
    for i, r in enumerate(rows):
        case = (r.get("case") or f"ROW{i}").strip()
        z_direct = r.get("z"); f_emit = r.get("f_emit_Hz"); f_obs = r.get("f_obs_Hz")
        z_obs = None; z_src = None
        try: z_direct = float(z_direct) if z_direct not in (None,"") else None
        except: z_direct = None
        try: f_emit = float(f_emit) if f_emit not in (None,"") else None
        except: f_emit = None
        try: f_obs = float(f_obs) if f_obs not in (None,"") else None
        except: f_obs = None
        if prefer_z and (z_direct is not None): z_obs = z_direct; z_src = "z"
        elif f_emit and f_obs and f_obs != 0: z_obs = f_emit / f_obs - 1.0; z_src = "freq"
        else: z_obs = z_direct; z_src = "z?"
        Msun = float(r.get("M_solar") or 0.0); M_c = Msun * float(M_sun)
        r_emit_m = r.get("r_emit_m"); r_eff = float(r_emit_m) if r_emit_m not in (None,"") else None
        v_los = float(r.get("v_los_mps") or 0.0); v_tot = float(r.get("v_tot_mps") or 0.0)
        z_gr = z_gravitational(M_c, r_eff) if (M_c>0 and r_eff and _m.isfinite(r_eff)) else float('nan')
        z_sr = z_special_rel(v_tot, v_los); z_grsr = z_combined(z_gr, z_sr)
        z_hint = r.get("z_geom_hint"); 
        try: z_hint = float(z_hint) if z_hint not in (None,"") else None
        except: z_hint = None
        lM = _m.log10(M_c) if (M_c and M_c>0) else _m.log10(float(M_sun))
        z_seg = z_seg_pred(mode, z_hint, z_gr, z_sr, z_grsr, dmA, dmB, dmAlpha, lM, lo, hi)
        def _d(a,b): 
            try: return (a-b)
            except: return float('nan')
        dz_seg  = _d(z_obs, z_seg)   if (z_obs is not None and _m.isfinite(z_seg))  else float('nan')
        dz_gr   = _d(z_obs, z_gr)    if (z_obs is not None and _m.isfinite(z_gr))   else float('nan')
        dz_sr   = _d(z_obs, z_sr)    if (z_obs is not None and _m.isfinite(z_sr))   else float('nan')
        dz_grsr = _d(z_obs, z_grsr)  if (z_obs is not None and _m.isfinite(z_grsr)) else float('nan')
        if _m.isfinite(dz_seg):  per_model_abs["seg"].append(abs(dz_seg))
        if _m.isfinite(dz_gr):   per_model_abs["gr"].append(abs(dz_gr))
        if _m.isfinite(dz_sr):   per_model_abs["sr"].append(abs(dz_sr))
        if _m.isfinite(dz_grsr): per_model_abs["grsr"].append(abs(dz_grsr))
        dbg.append({**r,"case":case,"z_source":z_src,"z_obs":z_obs,"z_gr":z_gr,"z_sr":z_sr,"z_grsr":z_grsr,"z_seg":z_seg,
                    "dz_seg":dz_seg,"dz_gr":dz_gr,"dz_sr":dz_sr,"dz_grsr":dz_grsr})
    if np is not None and per_model_abs["seg"]:
        med = {k: (float(np.median(v)) if v else float('nan')) for k,v in per_model_abs.items()}
    else:
        med = {k: (sorted(v)[len(v)//2] if v else float('nan')) for k,v in per_model_abs.items()}
    echo(f"Medians |Δz| -> seg: {med['seg']} | gr: {med['gr']} | sr: {med['sr']} | gr×sr: {med['grsr']}")
    return {"dbg": dbg, "med": med, "per_model_abs": per_model_abs, "lo": lo, "hi": hi}

def write_json(path: Path, obj: Any) -> None:
    path.write_text(json.dumps(obj, indent=2, ensure_ascii=False) + "\\n", encoding="utf-8"); echo(f"[OK] wrote JSON: {path}")

def write_csv(path: Path, rows: List[Dict[str, Any]]) -> None:
    if not rows: echo(f"[SKIP] nothing to write: {path}"); return
    cols = list(rows[0].keys())
    with path.open("w", encoding="utf-8", newline="") as f:
        import csv as _csv
        w = _csv.DictWriter(f, fieldnames=cols); w.writeheader(); w.writerows(rows)
    echo(f"[OK] wrote CSV: {path}")

def write_text(path: Path, text: str) -> None:
    path.write_text(text, encoding="utf-8"); echo(f"[OK] wrote text: {path}")

ORIGINAL_CODE_SHA256 = "2f255b36f97df89b72332c7b3d683b387d7ccaf7ee923bc1d35d901b10282d0a"
ORIGINAL_CODE_B64 = """IyEvdXNyL2Jpbi9lbnYgcHl0aG9uMwojIC0qLSBjb2Rpbmc6IHV0Zi04IC0qLQpmcm9tIF9fZnV0dXJlX18gaW1wb3J0IGFubm90YXRpb25zCgoiIiIKU0VHU1BBQ0Ug4oCTIEFsbC1pbi1PbmUgVG9vbGtpdAo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoKRnVua3Rpb25lbjoKICDigKIgz4AtQnJpZGdlIChDaHVkbm92c2t5L2J1aWx0aW4vcGhpKSArIERhdGFzZXQtRXZhbHVhdG9yIChTZWcgdnMgR1IvU1IvR1IqU1IpCiAg4oCiIM6UKE0pLU1hc3NlbnZhbGlkaWVydW5nIG1pdCBOZXd0b24tSW52ZXJzaW9uIChoaWdoLXByZWNpc2lvbiBEZWNpbWFsKQogIOKAoiBCb3VuZC1FbmVyZ3kgJiBsb2thbGUgRmVpbnN0cnVrdHVyLc6xIGF1cyBGcmVxdWVuenBhYXJlbiAoKyBvcHRpb25hbGVyIFBsb3QpCgpXaWNodGlnOgogIC0gLS1wcmVjIHdpcmQgZ2xvYmFsIFVORCBwcm8gU3ViY29tbWFuZCBha3plcHRpZXJ0LgogIC0gcGFuZGFzIGlzdCBmw7xyIHBpLWJyaWRnZSBlcmZvcmRlcmxpY2g7IG1hdHBsb3RsaWIgbnVyIGbDvHIgUGxvdHMuCiIiIgoKaW1wb3J0IGFyZ3BhcnNlLCBjc3YsIG1hdGgsIHN5cywgdGltZSwgc3RhdGlzdGljcyBhcyBzdGF0cywgaGFzaGxpYiwgdGV4dHdyYXAKZnJvbSBkYXRhY2xhc3NlcyBpbXBvcnQgZGF0YWNsYXNzCmZyb20gcGF0aGxpYiBpbXBvcnQgUGF0aApmcm9tIHR5cGluZyBpbXBvcnQgT3B0aW9uYWwsIFR1cGxlLCBMaXN0LCBEaWN0CgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiMgT3B0aW9uYWwgTGlicmFyaWVzCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KdHJ5OgogICAgaW1wb3J0IHBhbmRhcyBhcyBwZApleGNlcHQgRXhjZXB0aW9uOgogICAgcGQgPSBOb25lCgpkZWYgX2xhenlfbWF0cGxvdGxpYigpOgogICAgaW1wb3J0IG1hdHBsb3RsaWIucHlwbG90IGFzIHBsdAogICAgcmV0dXJuIHBsdAoKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQojIE51bWVyaWsgLyBLb25zdGFudGVuCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KZnJvbSBkZWNpbWFsIGltcG9ydCBEZWNpbWFsIGFzIEQsIGdldGNvbnRleHQKCiMgRGVmYXVsdC1QcmVjaXNpb24gKGthbm4gdmlhIENMSSBnbG9iYWwgb2RlciBwcm8gU3ViY29tbWFuZCBnZXNldHp0IHdlcmRlbikKZ2V0Y29udGV4dCgpLnByZWMgPSA4MAoKRyAgICAgPSBEKCc2LjY3NDMwZS0xMScpICAgICAgICMgbV4zIGtnXi0xIHNeLTIKYyAgICAgPSBEKCcyLjk5NzkyNDU4ZTgnKSAgICAgICMgbSBzXi0xCmggICAgID0gRCgnNi42MjYwNzAxNWUtMzQnKSAgICAjIEogcwpNX3N1biA9IEQoJzEuOTg4NDdlMzAnKQoKcGhpICAgPSAoRCgxKSArIEQoNSkuc3FydCgpKSAvIEQoMikgICAgICAjIGdvbGRlbmUgWmFobCB+MS42MTguLi4KQkxDICAgPSBwaGkgLyBEKDIpICAgICAgICAgICAgICAgICAgICAgICAjIM+GLzIgfiAwLjgwOTAxNy4uLgoKIyDOlChNKS1TdGFuZGFyZHBhcmFtZXRlciAoUGFwZXIgRGVmYXVsdHMpCkRNX0EgICAgID0gRCgnOTguMDEnKSAgICAgICAgIyAlCkRNX0FMUEhBID0gRCgnMi43MTc3ZTQnKSAgICAgIyAxL20KRE1fQiAgICAgPSBEKCcxLjk2JykgICAgICAgICAjICUKVE9MICAgICAgPSBEKCcxZS0xMjAnKQoKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQojIFV0aWxzCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KZGVmIGQoeCkgLT4gT3B0aW9uYWxbRF06CiAgICBpZiB4IGlzIE5vbmU6IHJldHVybiBOb25lCiAgICB0cnk6CiAgICAgICAgeHMgPSBzdHIoeCkuc3RyaXAoKQogICAgICAgIGlmIHhzID09ICIiOiByZXR1cm4gTm9uZQogICAgICAgIHJldHVybiBEKHhzKQogICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICByZXR1cm4gTm9uZQoKZGVmIGYyKHgsIGRlZmF1bHQ9Tm9uZSk6CiAgICB0cnk6CiAgICAgICAgaWYgeCBpcyBOb25lOiByZXR1cm4gZGVmYXVsdAogICAgICAgIHhzID0gc3RyKHgpLnN0cmlwKCkKICAgICAgICBpZiB4cyA9PSAiIjogcmV0dXJuIGRlZmF1bHQKICAgICAgICByZXR1cm4gZmxvYXQoeHMpCiAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgIHJldHVybiBkZWZhdWx0CgpkZWYgc2hhMjU2X2ZpbGUocGF0aDogUGF0aCkgLT4gc3RyOgogICAgaCA9IGhhc2hsaWIuc2hhMjU2KCkKICAgIHdpdGggcGF0aC5vcGVuKCdyYicpIGFzIGY6CiAgICAgICAgZm9yIGNodW5rIGluIGl0ZXIobGFtYmRhOiBmLnJlYWQoODE5MiksIGInJyk6CiAgICAgICAgICAgIGgudXBkYXRlKGNodW5rKQogICAgcmV0dXJuIGguaGV4ZGlnZXN0KCkKCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KIyBDaHVkbm92c2t5Lc+ACiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KZGVmIGNodWRub3Zza3lfcGkodGVybXM6IGludCwgcHJlYzogaW50KSAtPiBUdXBsZVtELCBmbG9hdF06CiAgICAiIiJDb21wdXRlIM+AIHZpYSBDaHVkbm92c2t5IHNlcmllcyB3aXRoICd0ZXJtcycgYW5kIERlY2ltYWwgcHJlY2lzaW9uICdwcmVjJy4iIiIKICAgIGZyb20gZGVjaW1hbCBpbXBvcnQgZ2V0Y29udGV4dAogICAgb2xkID0gZ2V0Y29udGV4dCgpLnByZWMKICAgIGdldGNvbnRleHQoKS5wcmVjID0gcHJlYwogICAgc3RhcnQgPSB0aW1lLnBlcmZfY291bnRlcigpCgogICAgQyA9IDQyNjg4MCAqIEQoMTAwMDUpLnNxcnQoKQogICAgTSA9IEQoMSk7IEwgPSBEKDEzNTkxNDA5KTsgWCA9IEQoMSk7IEsgPSBEKDYpOyBTID0gTAogICAgZm9yIF9rIGluIHJhbmdlKDEsIHRlcm1zKToKICAgICAgICBNID0gKE0gKiAoSyoqMyAtIDE2KkspKSAvIChEKF9rKSoqMykKICAgICAgICBMICs9IDU0NTE0MDEzNAogICAgICAgIFggKj0gLTI2MjUzNzQxMjY0MDc2ODAwMAogICAgICAgIFMgKz0gKE0gKiBMKSAvIFgKICAgICAgICBLICs9IDEyCgogICAgcGkgPSBDIC8gUwogICAgZHQgPSAodGltZS5wZXJmX2NvdW50ZXIoKSAtIHN0YXJ0KSAqIDEwMDAuMCAgIyBtcwogICAgZ2V0Y29udGV4dCgpLnByZWMgPSBvbGQKICAgIHJldHVybiArcGksIGR0CgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiMgT3JiaXRhbC9SZWRzaGlmdCBQaHlzaWsKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpkZWYgZGVnMnJhZChkZyk6IHJldHVybiBkZyAqIG1hdGgucGkgLyAxODAuMAoKZGVmIHJfZnJvbV9vcmJpdChhX20sIGUsIGZfdHJ1ZV9yYWQpOgogICAgZGVub20gPSAoMS4wICsgZSptYXRoLmNvcyhmX3RydWVfcmFkKSkKICAgIGlmIGRlbm9tID09IDA6IHJldHVybiBmbG9hdCgnbmFuJykKICAgIHJldHVybiBhX20gKiAoMS4wIC0gZSplKSAvIGRlbm9tCgpkZWYgdmlzX3ZpdmEobXUsIGFfbSwgcl9tKToKICAgIHRlcm0gPSBtdSAqICgyLjAvbWF4KHJfbSwgMWUtOTkpIC0gMS4wL21heChhX20sIDFlLTk5KSkKICAgIHJldHVybiBtYXRoLnNxcnQodGVybSkgaWYgdGVybSA+PSAwLjAgZWxzZSBmbG9hdCgnbmFuJykKCmRlZiB6X2dyYXZpdGF0aW9uYWwoTV9jZW50cmFsX2tnOiBmbG9hdCwgcl9tOiBmbG9hdCkgLT4gZmxvYXQ6CiAgICBpZiBub3QgKE1fY2VudHJhbF9rZyA+IDAgYW5kIHJfbSBhbmQgbWF0aC5pc2Zpbml0ZShyX20pIGFuZCByX20gPiAwKTogcmV0dXJuIGZsb2F0KCduYW4nKQogICAgcnMgPSAyLjAgKiBmbG9hdChHKSAqIE1fY2VudHJhbF9rZyAvIChmbG9hdChjKSoqMikKICAgIGlmIHJfbSA8PSByczogcmV0dXJuIGZsb2F0KCduYW4nKQogICAgcmV0dXJuIDEuMCAvIG1hdGguc3FydCgxLjAgLSBycy9yX20pIC0gMS4wCgpkZWYgel9zcGVjaWFsX3JlbCh2X3RvdF9tcHM6IGZsb2F0LCB2X2xvc19tcHM6IGZsb2F0ID0gMC4wKSAtPiBmbG9hdDoKICAgIGlmIHZfdG90X21wcyBpcyBOb25lIG9yIG5vdCBtYXRoLmlzZmluaXRlKHZfdG90X21wcyk6IHJldHVybiBmbG9hdCgnbmFuJykKICAgIHZfdG90X2FicyA9IGFicyh2X3RvdF9tcHMpCiAgICBpZiB2X3RvdF9hYnMgPD0gMDogcmV0dXJuIGZsb2F0KCduYW4nKQogICAgY19mID0gZmxvYXQoYykKICAgIGJldGEgPSBtaW4odl90b3RfYWJzIC8gY19mLCAwLjk5OTk5OTk5OTk5OSkKICAgIGJldGFfbG9zID0gMC4wIGlmIHZfbG9zX21wcyBpcyBOb25lIG9yIChub3QgbWF0aC5pc2Zpbml0ZSh2X2xvc19tcHMpKSBlbHNlICh2X2xvc19tcHMgLyBjX2YpCiAgICBnYW1tYSA9IDEuMCAvIG1hdGguc3FydCgxLjAgLSBiZXRhKmJldGEpCiAgICByZXR1cm4gZ2FtbWEgKiAoMS4wICsgYmV0YV9sb3MpIC0gMS4wCgpkZWYgel9jb21iaW5lZCh6X2dyOiBmbG9hdCwgel9zcjogZmxvYXQpIC0+IGZsb2F0OgogICAgemdyID0gMC4wIGlmICh6X2dyIGlzIE5vbmUgb3Igbm90IG1hdGguaXNmaW5pdGUoel9ncikpIGVsc2Ugel9ncgogICAgenNyID0gMC4wIGlmICh6X3NyIGlzIE5vbmUgb3Igbm90IG1hdGguaXNmaW5pdGUoel9zcikpIGVsc2Ugel9zcgogICAgcmV0dXJuICgxLjAgKyB6Z3IpICogKDEuMCArIHpzcikgLSAxLjAKCmRlZiBvYnNlcnZlZF96KHJvdzogZGljdCwgcHJlZmVyX3o6IGJvb2wpIC0+IFR1cGxlW09wdGlvbmFsW2Zsb2F0XSwgc3RyXToKICAgIHpfZGlyZWN0ID0gZjIocm93LmdldCgieiIpKQogICAgZl9lbWl0ICAgPSBmMihyb3cuZ2V0KCJmX2VtaXRfSHoiKSkKICAgIGZfb2JzICAgID0gZjIocm93LmdldCgiZl9vYnNfSHoiKSkKICAgIGlmIHByZWZlcl96IGFuZCB6X2RpcmVjdCBpcyBub3QgTm9uZToKICAgICAgICByZXR1cm4gel9kaXJlY3QsICJ6IgogICAgaWYgKGZfZW1pdCBpcyBub3QgTm9uZSkgYW5kIChmX29icyBpcyBub3QgTm9uZSkgYW5kIChmX29icyAhPSAwLjApOgogICAgICAgIHJldHVybiAoZl9lbWl0IC8gZl9vYnMgLSAxLjApLCAiZnJlcSIKICAgIHJldHVybiB6X2RpcmVjdCwgKCJ6IiBpZiB6X2RpcmVjdCBpcyBub3QgTm9uZSBlbHNlICJtaXNzaW5nIikKCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KIyDOlChNKS1Nb2RlbGwgJiBJbnZlcnNpb24KIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpkZWYgZG1fcmF3KE06IEQsIEE6IEQgPSBETV9BLCBhbHBoYTogRCA9IERNX0FMUEhBLCBCOiBEID0gRE1fQikgLT4gRDoKICAgIHJzID0gKEQoMikgKiBHICogTSkgLyAoYyoqMikKICAgIHJldHVybiBBICogKC0oYWxwaGEqcnMpKS5leHAoKSArIEIKCmRlZiBkbV9ub3JtX2JvdW5kcyhtYXNzZXM6IExpc3RbRF0pIC0+IFR1cGxlW0QsIERdOgogICAgbG9ncyA9IFtEKHN0cihtYXRoLmxvZzEwKG0pKSkgZm9yIG0gaW4gbWFzc2VzIGlmIG0gPiAwXQogICAgaWYgbm90IGxvZ3M6IHJldHVybiBEKCcwJyksIEQoJzEnKQogICAgTG1pbiwgTG1heCA9IG1pbihsb2dzKSwgbWF4KGxvZ3MpCiAgICBpZiBMbWF4IDw9IExtaW46CiAgICAgICAgTG1pbiwgTG1heCA9IExtaW4gLSBEKCcwLjUnKSwgTG1pbiArIEQoJzAuNScpCiAgICByZXR1cm4gTG1pbiwgTG1heAoKZGVmIGRtX3BlcmNlbnQoTTogRCwgTG1pbjogRCwgTG1heDogRCwgQTogRCA9IERNX0EsIGFscGhhOiBEID0gRE1fQUxQSEEsIEI6IEQgPSBETV9CKSAtPiBEOgogICAgaWYgTSA8PSAwOiByZXR1cm4gRCgwKQogICAgbm9ybSA9IChEKHN0cihtYXRoLmxvZzEwKE0pKSkgLSBMbWluKSAvIChMbWF4IC0gTG1pbikKICAgIG5vcm0gPSBtYXgoRCgwKSwgbWluKEQoMSksIG5vcm0pKQogICAgcmV0dXJuIGRtX3JhdyhNLCBBLCBhbHBoYSwgQikgKiBub3JtCgpkZWYgcnBoaV9mcm9tX21hc3MoTTogRCkgLT4gRDoKICAgIHJldHVybiAoRyAqIE0gLyAoYyoqMikpICogcGhpCgpkZWYgbWFzc19mcm9tX3JwaGkocl9waGk6IEQpIC0+IEQ6CiAgICByZXR1cm4gKGMqKjIpICogcl9waGkgLyAoRyAqIHBoaSkKCmRlZiBmX21hc3NfZXEoTTogRCwgcl9vYnM6IEQsIExtaW46IEQsIExtYXg6IEQsCiAgICAgICAgICAgICAgQTogRCA9IERNX0EsIGFscGhhOiBEID0gRE1fQUxQSEEsIEI6IEQgPSBETV9CKSAtPiBEOgogICAgcmV0dXJuIChHKnBoaSpNL2MqKjIpICogKEQoMSkgKyBkbV9wZXJjZW50KE0sIExtaW4sIExtYXgsIEEsIGFscGhhLCBCKS9EKDEwMCkpIC0gcl9vYnMKCmRlZiBkZl9kTShNOiBELCByX29iczogRCwgTG1pbjogRCwgTG1heDogRCwKICAgICAgICAgIEE6IEQgPSBETV9BLCBhbHBoYTogRCA9IERNX0FMUEhBLCBCOiBEID0gRE1fQikgLT4gRDoKICAgIGggPSBNICogRCgnMWUtMjUnKSBpZiBNICE9IDAgZWxzZSBEKCcxZS0yNScpCiAgICByZXR1cm4gKGZfbWFzc19lcShNK2gsIHJfb2JzLCBMbWluLCBMbWF4LCBBLCBhbHBoYSwgQikgLSBmX21hc3NfZXEoTS1oLCByX29icywgTG1pbiwgTG1heCwgQSwgYWxwaGEsIEIpKSAvIChEKDIpKmgpCgpkZWYgaW52ZXJ0X21hc3Mocl9vYnM6IEQsIE0wOiBELCBMbWluOiBELCBMbWF4OiBELAogICAgICAgICAgICAgICAgQTogRCA9IERNX0EsIGFscGhhOiBEID0gRE1fQUxQSEEsIEI6IEQgPSBETV9CKSAtPiBEOgogICAgTSA9IG1heChNMCwgRCgnMWUtNTAnKSkKICAgIGZvciBfIGluIHJhbmdlKDIwMCk6CiAgICAgICAgeSA9IGZfbWFzc19lcShNLCByX29icywgTG1pbiwgTG1heCwgQSwgYWxwaGEsIEIpCiAgICAgICAgaWYgYWJzKHkpIDwgVE9MOiBicmVhawogICAgICAgIHN0ZXAgPSAteSAvIGRmX2RNKE0sIHJfb2JzLCBMbWluLCBMbWF4LCBBLCBhbHBoYSwgQikKICAgICAgICB3aGlsZSBhYnMoc3RlcCkgPiBhYnMoTSk6CiAgICAgICAgICAgIHN0ZXAgKj0gRCgnMC41JykKICAgICAgICBNICs9IHN0ZXAKICAgICAgICBpZiBhYnMoc3RlcCAvIE0pIDwgVE9MOiBicmVhawogICAgcmV0dXJuIE0KCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KIyBTZWctTW9kZWxsIChIaW50IC8gzpRNIC8gSHlicmlkKQojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCmRlZiB6X3NlZ19oaW50KHJvdzogZGljdCwgel9zcjogZmxvYXQsIHpfZ3JzcjogZmxvYXQpIC0+IGZsb2F0OgogICAgel9oaW50ID0gZjIocm93LmdldCgiel9nZW9tX2hpbnQiKSkKICAgIGlmIHpfaGludCBpcyBub3QgTm9uZSBhbmQgbWF0aC5pc2Zpbml0ZSh6X2hpbnQpOgogICAgICAgIHJldHVybiB6X2NvbWJpbmVkKHpfaGludCwgel9zcikKICAgIHJldHVybiB6X2dyc3IKCmRlZiB6X3NlZ19kZWx0YW0ocm93OiBkaWN0LCB6X2dyOiBmbG9hdCwgel9zcjogZmxvYXQsCiAgICAgICAgICAgICAgICAgQTogZmxvYXQsIEI6IGZsb2F0LCBhbHBoYV9tOiBmbG9hdCwKICAgICAgICAgICAgICAgICBsb2dNX21pbjogT3B0aW9uYWxbZmxvYXRdLCBsb2dNX21heDogT3B0aW9uYWxbZmxvYXRdLAogICAgICAgICAgICAgICAgIGRhdGFzZXRfTG1pbjogT3B0aW9uYWxbZmxvYXRdLCBkYXRhc2V0X0xtYXg6IE9wdGlvbmFsW2Zsb2F0XSkgLT4gZmxvYXQ6CiAgICBNc3VuID0gZjIocm93LmdldCgiTV9zb2xhciIpKQogICAgaWYgTXN1biBpcyBOb25lIG9yIG5vdCBtYXRoLmlzZmluaXRlKE1zdW4pIG9yIE1zdW4gPD0gMDoKICAgICAgICByZXR1cm4gel9jb21iaW5lZCh6X2dyLCB6X3NyKQogICAgTSA9IE1zdW4gKiBmbG9hdChNX3N1bikKICAgIHJzID0gMi4wICogZmxvYXQoRykgKiBNIC8gKGZsb2F0KGMpKioyKQogICAgbE0gPSBtYXRoLmxvZzEwKE0pCiAgICBsbyA9IChsb2dNX21pbiBpZiAobG9nTV9taW4gaXMgbm90IE5vbmUpIGVsc2UgZGF0YXNldF9MbWluKQogICAgaGkgPSAobG9nTV9tYXggaWYgKGxvZ01fbWF4IGlzIG5vdCBOb25lKSBlbHNlIGRhdGFzZXRfTG1heCkKICAgIGlmIChsbyBpcyBOb25lKSBvciAoaGkgaXMgTm9uZSkgb3IgKGhpIDw9IGxvKToKICAgICAgICBsbywgaGkgPSBsTSAtIDAuNSwgbE0gKyAwLjUKICAgIG5vcm0gPSAobE0gLSBsbykgLyAoaGkgLSBsbykKICAgIG5vcm0gPSBtaW4oMS4wLCBtYXgoMC4wLCBub3JtKSkKICAgIGRlbHRhX3BjdCA9IChBICogbWF0aC5leHAoLWFscGhhX20gKiBycykgKyBCKSAqIG5vcm0KICAgIHpfZ3Jfc2NhbGVkID0gel9nciAqICgxLjAgKyBkZWx0YV9wY3QvMTAwLjApCiAgICByZXR1cm4gel9jb21iaW5lZCh6X2dyX3NjYWxlZCwgel9zcikKCmRlZiB6X3NlZyhyb3c6IGRpY3QsIG1vZGU6IHN0ciwgel9ncjogZmxvYXQsIHpfc3I6IGZsb2F0LCB6X2dyc3I6IGZsb2F0LAogICAgICAgICAgZG1BOiBmbG9hdCwgZG1COiBmbG9hdCwgZG1BbHBoYTogZmxvYXQsCiAgICAgICAgICBsb2dNX21pbjogT3B0aW9uYWxbZmxvYXRdLCBsb2dNX21heDogT3B0aW9uYWxbZmxvYXRdLAogICAgICAgICAgZGF0YXNldF9MbWluOiBPcHRpb25hbFtmbG9hdF0sIGRhdGFzZXRfTG1heDogT3B0aW9uYWxbZmxvYXRdLAogICAgICAgICAgdXNlX2VtaXNzaW9uX2dhdGU6IGJvb2wgPSBUcnVlKSAtPiBmbG9hdDoKICAgIGlmIG1vZGUgPT0gImhpbnQiOgogICAgICAgIHJldHVybiB6X3NlZ19oaW50KHJvdywgel9zciwgel9ncnNyKQogICAgZWxpZiBtb2RlID09ICJkZWx0YU0iOgogICAgICAgIHJldHVybiB6X3NlZ19kZWx0YW0ocm93LCB6X2dyLCB6X3NyLCBkbUEsIGRtQiwgZG1BbHBoYSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ01fbWluLCBsb2dNX21heCwgZGF0YXNldF9MbWluLCBkYXRhc2V0X0xtYXgpCiAgICBlbGlmIG1vZGUgPT0gImh5YnJpZCI6CiAgICAgICAgel9oaW50ID0gZjIocm93LmdldCgiel9nZW9tX2hpbnQiKSkKICAgICAgICBjYXNlID0gc3RyKHJvdy5nZXQoImNhc2UiLCIiKSkubG93ZXIoKQogICAgICAgIGNhdGVnb3J5ID0gc3RyKHJvdy5nZXQoImNhdGVnb3J5IiwiIikpLmxvd2VyKCkKICAgICAgICAjIEJlaXNwaWVsLUhldXJpc3RpazogUy1TdGVybmUgbnV0emVuIEhpbnQsIHNvbnN0IM6UTQogICAgICAgICMgT3B0aW9uYWxlcyBFbWlzc2lvbnMtR2F0ZTogbnVyIHdlbm4gYWt0aXZpZXJ0CiAgICAgICAgaWYgdXNlX2VtaXNzaW9uX2dhdGU6CiAgICAgICAgICAgIGJhZF9mb3JfZGVsdGFNID0gKCJqZXQiLCJwc3IiLCJwdWxzYXIiLCJibF9sYWMiLCIzYyIsImFnbiIsInF1YXNhciIpCiAgICAgICAgICAgIGlmIGFueSgodCBpbiBjYXNlKSBvciAodCBpbiBjYXRlZ29yeSkgZm9yIHQgaW4gYmFkX2Zvcl9kZWx0YU0pOgogICAgICAgICAgICAgICAgcmV0dXJuIHpfZ3JzcgogICAgICAgICMgRW1pc3Npb25za2xhc3Nlbi1HYXRlOiBGw7xyIGJla2FubnRlIE5pY2h0Lc6UKE0pLUbDpGxsZSAoSmV0cy9QdWxzYXJlL0JMIExhY3MvQUdOL1F1YXNhcmUpCiAgICAgICAgIyB2ZXJ3ZW5kZW4gd2lyIEdSKlNSICh6X2dyc3IpLCBkYSDOlChNKS1IZXVyaXN0aWsgZG9ydCBuaWNodCBwYXNzdC4KICAgICAgICBiYWRfZm9yX2RlbHRhTSA9ICgiamV0IiwicHNyIiwicHVsc2FyIiwiYmxfbGFjIiwiM2MiLCJhZ24iLCJxdWFzYXIiKQogICAgICAgIGlmIGFueSgodCBpbiBjYXNlKSBvciAodCBpbiBjYXRlZ29yeSkgZm9yIHQgaW4gYmFkX2Zvcl9kZWx0YU0pOgogICAgICAgICAgICByZXR1cm4gel9ncnNyCiAgICAgICAgaWYgKCJzLXN0YXIiIGluIGNhdGVnb3J5IG9yICJzZ3JhIiBpbiBjYXNlKSBhbmQgel9oaW50IGlzIG5vdCBOb25lOgogICAgICAgICAgICByZXR1cm4gel9zZWdfaGludChyb3csIHpfc3IsIHpfZ3JzcikKICAgICAgICByZXR1cm4gel9zZWdfZGVsdGFtKHJvdywgel9nciwgel9zciwgZG1BLCBkbUIsIGRtQWxwaGEsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dNX21pbiwgbG9nTV9tYXgsIGRhdGFzZXRfTG1pbiwgZGF0YXNldF9MbWF4KQogICAgcmV0dXJuIHpfZ3JzcgoKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQojIEV2YWx1YXRvciAoQ1NWLURhdGVuc2F0eikKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpkZWYgcm9idXN0X21lYW4odmVjKToKICAgIGlmIG5vdCB2ZWM6IHJldHVybiBOb25lCiAgICBtID0gc3RhdHMubWVkaWFuKHZlYykKICAgIG1hZCA9IHN0YXRzLm1lZGlhbihbYWJzKHgtbSkgZm9yIHggaW4gdmVjXSkgaWYgbGVuKHZlYykgPiAxIGVsc2UgMC4wCiAgICBmaWx0ZXJlZCA9IFt4IGZvciB4IGluIHZlYyBpZiAobWFkID09IDAgb3IgYWJzKHgtbSkgPD0gNSptYWQpXQogICAgcmV0dXJuIHN1bShmaWx0ZXJlZCkvbGVuKGZpbHRlcmVkKSBpZiBmaWx0ZXJlZCBlbHNlIG0KCmRlZiBldmFsdWF0ZV9kYXRhc2V0KGRmLCBwcmVmZXJfejogYm9vbCwgc2VnX21vZGU6IHN0ciwgb3V0ZGlyOiBQYXRoLAogICAgICAgICAgICAgICAgICAgICBkbUE6IGZsb2F0LCBkbUI6IGZsb2F0LCBkbUFscGhhOiBmbG9hdCwKICAgICAgICAgICAgICAgICAgICAgbG9nTV9taW46IE9wdGlvbmFsW2Zsb2F0XSwgbG9nTV9tYXg6IE9wdGlvbmFsW2Zsb2F0XSwKICAgICAgICAgICAgICAgICAgICAgbWFrZV9wbG90czogYm9vbCwgdG9wX2s6IGludCA9IDEwLAogICAgICAgICAgICAgICAgICAgICB1c2VfZW1pc3Npb25fZ2F0ZTogYm9vbCA9IFRydWUpOgogICAgb3V0ZGlyLm1rZGlyKHBhcmVudHM9VHJ1ZSwgZXhpc3Rfb2s9VHJ1ZSkKICAgIGlmIHBkIGlzIE5vbmU6CiAgICAgICAgcmFpc2UgUnVudGltZUVycm9yKCJwYW5kYXMgcmVxdWlyZWQgZm9yIGRhdGFzZXQgZXZhbHVhdGlvbi4gcGlwIGluc3RhbGwgcGFuZGFzIikKCiAgICAjIGxvZ00gQm91bmRzIGF1cyBEYXRlbnNhdHoKICAgIE1zID0gW10KICAgIGZvciBfLCByIGluIGRmLml0ZXJyb3dzKCk6CiAgICAgICAgTXN1biA9IGYyKHIuZ2V0KCJNX3NvbGFyIikpCiAgICAgICAgaWYgTXN1biBhbmQgTXN1biA+IDA6IE1zLmFwcGVuZChEKHN0cihNc3VuKSkgKiBNX3N1bikKICAgIExtaW4sIExtYXggPSBkbV9ub3JtX2JvdW5kcyhNcykgaWYgTXMgZWxzZSAoRCgnMCcpLCBEKCcxJykpCgogICAgZGJnX3Jvd3MgPSBbXQogICAgcGVyX21vZGVsX2FicyA9IHsic2VnIjogW10sICJnciI6IFtdLCAic3IiOiBbXSwgImdyc3IiOiBbXX0KICAgIHJhdGlvc192c19nciA9IFtdCiAgICByYXRpb3NfdnNfZ3JzciA9IFtdCgogICAgZm9yIGlkeCwgciBpbiBkZi5pdGVycm93cygpOgogICAgICAgIHJvdyA9IHtrOiByW2tdIGZvciBrIGluIGRmLmNvbHVtbnN9CiAgICAgICAgY2FzZSA9IHN0cihyb3cuZ2V0KCJjYXNlIiwgIiIpKS5zdHJpcCgpIG9yIGYiUk9Xe2lkeH0iCgogICAgICAgICMgQmVvYmFjaHR1bmcKICAgICAgICB6X29icywgel9zcmMgPSBvYnNlcnZlZF96KHJvdywgcHJlZmVyX3o9cHJlZmVyX3opCiAgICAgICAgaWYgel9vYnMgaXMgTm9uZSBvciBub3QgbWF0aC5pc2Zpbml0ZSh6X29icyk6CiAgICAgICAgICAgIGRiZ19yb3dzLmFwcGVuZCh7Kipyb3csICJjYXNlIjogY2FzZSwgInpfc291cmNlIjogel9zcmMsICJub3RlIjogIm5vIG9ic2VydmVkIHoifSkKICAgICAgICAgICAgY29udGludWUKCiAgICAgICAgIyBHZW9tZXRyaWUgLyBHZXNjaHdpbmRpZ2tlaXRlbgogICAgICAgIE1zdW4gPSBmMihyb3cuZ2V0KCJNX3NvbGFyIikpCiAgICAgICAgTV9jID0gKE1zdW4gb3IgMC4wKSAqIGZsb2F0KE1fc3VuKQogICAgICAgIGFfbSA9IGYyKHJvdy5nZXQoImFfbSIpKQogICAgICAgIGUgICA9IGYyKHJvdy5nZXQoImUiKSkKICAgICAgICBmZGVnPSBmMihyb3cuZ2V0KCJmX3RydWVfZGVnIikpCiAgICAgICAgcl9lbWl0X20gPSBmMihyb3cuZ2V0KCJyX2VtaXRfbSIpKQoKICAgICAgICBpZiByX2VtaXRfbSBpcyBub3QgTm9uZSBhbmQgbWF0aC5pc2Zpbml0ZShyX2VtaXRfbSkgYW5kIHJfZW1pdF9tID4gMDoKICAgICAgICAgICAgcl9lZmYgPSByX2VtaXRfbQogICAgICAgICAgICByX25vdGUgPSAicl9lbWl0X20iCiAgICAgICAgZWxpZiBhbGwodiBpcyBub3QgTm9uZSBmb3IgdiBpbiAoYV9tLCBlLCBmZGVnKSk6CiAgICAgICAgICAgIHJfZWZmID0gcl9mcm9tX29yYml0KGFfbSwgZSwgZGVnMnJhZChmZGVnKSkKICAgICAgICAgICAgcl9ub3RlID0gInIoYSxlLGYpIgogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHJfZWZmLCByX25vdGUgPSBOb25lLCAibm8gciIKCiAgICAgICAgdl9sb3MgPSBmMihyb3cuZ2V0KCJ2X2xvc19tcHMiKSkgb3IgMC4wCiAgICAgICAgdl90b3QgPSBmMihyb3cuZ2V0KCJ2X3RvdF9tcHMiKSkKCiAgICAgICAgIyBCYXNlbGluZXMKICAgICAgICB6X2dyID0gel9ncmF2aXRhdGlvbmFsKE1fYywgcl9lZmYpCiAgICAgICAgel9zciA9IHpfc3BlY2lhbF9yZWwodl90b3QsIHZfbG9zKQogICAgICAgIHpfZ3JzciA9IHpfY29tYmluZWQoel9nciwgel9zcikKICAgICAgICAjIFNlZ21lbnRlZAogICAgICAgIHpfc2cgICA9IHpfc2VnKHJvdywgc2VnX21vZGUsIHpfZ3IsIHpfc3IsIHpfZ3JzciwKICAgICAgICAgICAgICAgICAgICAgICBkbUEsIGRtQiwgZG1BbHBoYSwgbG9nTV9taW4sIGxvZ01fbWF4LAogICAgICAgICAgICAgICAgICAgICAgIGZsb2F0KExtaW4pLCBmbG9hdChMbWF4KSwKICAgICAgICAgICAgICAgICAgICAgICB1c2VfZW1pc3Npb25fZ2F0ZT11c2VfZW1pc3Npb25fZ2F0ZSkKCiAgICAgICAgZHpfc2VnICA9ICh6X29icyAtIHpfc2cpICAgIGlmIG1hdGguaXNmaW5pdGUoel9zZykgICBlbHNlIGZsb2F0KCduYW4nKQogICAgICAgIGR6X2dyICAgPSAoel9vYnMgLSB6X2dyKSAgICBpZiBtYXRoLmlzZmluaXRlKHpfZ3IpICAgZWxzZSBmbG9hdCgnbmFuJykKICAgICAgICBkel9zciAgID0gKHpfb2JzIC0gel9zcikgICAgaWYgbWF0aC5pc2Zpbml0ZSh6X3NyKSAgIGVsc2UgZmxvYXQoJ25hbicpCiAgICAgICAgZHpfZ3JzciA9ICh6X29icyAtIHpfZ3JzcikgIGlmIG1hdGguaXNmaW5pdGUoel9ncnNyKSBlbHNlIGZsb2F0KCduYW4nKQoKICAgICAgICBpZiBtYXRoLmlzZmluaXRlKGR6X3NlZyk6ICBwZXJfbW9kZWxfYWJzWyJzZWciXS5hcHBlbmQoYWJzKGR6X3NlZykpCiAgICAgICAgaWYgbWF0aC5pc2Zpbml0ZShkel9ncik6ICAgcGVyX21vZGVsX2Fic1siZ3IiXS5hcHBlbmQoYWJzKGR6X2dyKSkKICAgICAgICBpZiBtYXRoLmlzZmluaXRlKGR6X3NyKTogICBwZXJfbW9kZWxfYWJzWyJzciJdLmFwcGVuZChhYnMoZHpfc3IpKQogICAgICAgIGlmIG1hdGguaXNmaW5pdGUoZHpfZ3Jzcik6IHBlcl9tb2RlbF9hYnNbImdyc3IiXS5hcHBlbmQoYWJzKGR6X2dyc3IpKQoKICAgICAgICBpZiBtYXRoLmlzZmluaXRlKGR6X2dyKSBhbmQgYWJzKGR6X2dyKSA+IDAgYW5kIG1hdGguaXNmaW5pdGUoZHpfc2VnKToKICAgICAgICAgICAgcmF0aW9zX3ZzX2dyLmFwcGVuZCgoY2FzZSwgYWJzKGR6X3NlZykvYWJzKGR6X2dyKSwgYWJzKGR6X3NlZyksIGFicyhkel9ncikpKQogICAgICAgIGlmIG1hdGguaXNmaW5pdGUoZHpfZ3JzcikgYW5kIGFicyhkel9ncnNyKSA+IDAgYW5kIG1hdGguaXNmaW5pdGUoZHpfc2VnKToKICAgICAgICAgICAgcmF0aW9zX3ZzX2dyc3IuYXBwZW5kKChjYXNlLCBhYnMoZHpfc2VnKS9hYnMoZHpfZ3JzciksIGFicyhkel9zZWcpLCBhYnMoZHpfZ3JzcikpKQoKICAgICAgICBkYmdfcm93cy5hcHBlbmQoewogICAgICAgICAgICAqKnJvdywKICAgICAgICAgICAgImNhc2UiOiBjYXNlLAogICAgICAgICAgICAiel9vYnMiOiB6X29icywgInpfc291cmNlIjogel9zcmMsCiAgICAgICAgICAgICJyX2VmZl9tIjogcl9lZmYgaWYgKHJfZWZmIGlzIG5vdCBOb25lIGFuZCBtYXRoLmlzZmluaXRlKHJfZWZmKSkgZWxzZSAiIiwKICAgICAgICAgICAgInJfbm90ZSI6IHJfbm90ZSwKICAgICAgICAgICAgInZfdG90X21wcyI6IHZfdG90IGlmICh2X3RvdCBpcyBub3QgTm9uZSBhbmQgbWF0aC5pc2Zpbml0ZSh2X3RvdCkpIGVsc2UgIiIsCiAgICAgICAgICAgICJ2X2xvc19tcHMiOiB2X2xvcyBpZiAodl9sb3MgaXMgbm90IE5vbmUgYW5kIG1hdGguaXNmaW5pdGUodl9sb3MpKSBlbHNlICIiLAogICAgICAgICAgICAiel9nciI6IHpfZ3IgaWYgbWF0aC5pc2Zpbml0ZSh6X2dyKSBlbHNlICIiLAogICAgICAgICAgICAiel9zciI6IHpfc3IgaWYgbWF0aC5pc2Zpbml0ZSh6X3NyKSBlbHNlICIiLAogICAgICAgICAgICAiel9ncnNyIjogel9ncnNyIGlmIG1hdGguaXNmaW5pdGUoel9ncnNyKSBlbHNlICIiLAogICAgICAgICAgICAiel9zZWciOiB6X3NnIGlmIG1hdGguaXNmaW5pdGUoel9zZykgZWxzZSAiIiwKICAgICAgICAgICAgImR6X3NlZyI6IGR6X3NlZyBpZiBtYXRoLmlzZmluaXRlKGR6X3NlZykgZWxzZSAiIiwKICAgICAgICAgICAgImR6X2dyIjogZHpfZ3IgaWYgbWF0aC5pc2Zpbml0ZShkel9ncikgZWxzZSAiIiwKICAgICAgICAgICAgImR6X3NyIjogZHpfc3IgaWYgbWF0aC5pc2Zpbml0ZShkel9zcikgZWxzZSAiIiwKICAgICAgICAgICAgImR6X2dyc3IiOiBkel9ncnNyIGlmIG1hdGguaXNmaW5pdGUoZHpfZ3JzcikgZWxzZSAiIiwKICAgICAgICB9KQoKICAgIGRlZiBzdW1tYXJpemUodmVjKToKICAgICAgICBpZiBub3QgdmVjOiByZXR1cm4gKE5vbmUsIE5vbmUsIE5vbmUpCiAgICAgICAgcmV0dXJuIChzdGF0cy5tZWRpYW4odmVjKSwgcm9idXN0X21lYW4odmVjKSwgbWF4KHZlYykpCgogICAgbWVkX3NlZywgbWVhbl9zZWcsIG1heF9zZWcgPSBzdW1tYXJpemUocGVyX21vZGVsX2Fic1sic2VnIl0pCiAgICBtZWRfZ3IsICBtZWFuX2dyLCAgbWF4X2dyICA9IHN1bW1hcml6ZShwZXJfbW9kZWxfYWJzWyJnciJdKQogICAgbWVkX3NyLCAgbWVhbl9zciwgIG1heF9zciAgPSBzdW1tYXJpemUocGVyX21vZGVsX2Fic1sic3IiXSkKICAgIG1lZF9ncnNyLG1lYW5fZ3JzcixtYXhfZ3Jzcj0gc3VtbWFyaXplKHBlcl9tb2RlbF9hYnNbImdyc3IiXSkKCiAgICBvdXRkaXIubWtkaXIocGFyZW50cz1UcnVlLCBleGlzdF9vaz1UcnVlKQogICAgZGJnX3BhdGggPSBvdXRkaXIgLyAic2Vnc3BhY2VfZGVidWcuY3N2IgogICAgaWYgcGQgaXMgbm90IE5vbmU6CiAgICAgICAgcGQuRGF0YUZyYW1lKGRiZ19yb3dzKS50b19jc3YoZGJnX3BhdGgsIGluZGV4PUZhbHNlKQoKICAgIHJlcCA9IHRleHR3cmFwLmRlZGVudChmIiIiCiAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgICBTRUdNRU5URUQgU1BBQ0VUSU1FIOKAkyBEQVRBU0VUIEVWQUxVQVRJT04KICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQogICAgUm93cyB1c2VkOiB7bGVuKGRiZ19yb3dzKX0KICAgIHNlZy1tb2RlIDoge3NlZ19tb2RlfQogICAgzpQoTSkgICAgIDogQT17ZG1BfSUgIEI9e2RtQn0lICBhbHBoYT17ZG1BbHBoYX0gWzEvbV0KICAgIGxvZ00gICAgIDogdXNlcj1be2xvZ01fbWlufSx7bG9nTV9tYXh9XSAgZGF0YXNldD1be2Zsb2F0KExtaW4pOi4zZn0se2Zsb2F0KExtYXgpOi4zZn1dCgogICAgTWVkaWFuL01lYW4vTWF4IHzOlHp8CiAgICAgIFNlZyAgIDoge21lZF9zZWchczo+MTB9ICB7bWVhbl9zZWchczo+MTB9ICB7bWF4X3NlZyFzOj4xMH0KICAgICAgR1IgICAgOiB7bWVkX2dyIXM6PjEwfSAge21lYW5fZ3Ihczo+MTB9ICB7bWF4X2dyIXM6PjEwfQogICAgICBTUiAgICA6IHttZWRfc3Ihczo+MTB9ICB7bWVhbl9zciFzOj4xMH0gIHttYXhfc3Ihczo+MTB9CiAgICAgIEdSKlNSIDoge21lZF9ncnNyIXM6PjEwfSAge21lYW5fZ3JzciFzOj4xMH0gIHttYXhfZ3JzciFzOj4xMH0KCiAgICBQZXJmb3JtYW5jZSB2cyBHUiAoTWVkaWFuKTogeyAobWVkX3NlZy9tZWRfZ3IgaWYgbWVkX3NlZyBhbmQgbWVkX2dyIGVsc2UgJ04vQScpIH0gw5cKICAgIERlYnVnIENTViAgOiB7ZGJnX3BhdGh9CiAgICAiIiIpLnN0cmlwKCJcbiIpCiAgICBwcmludChyZXApCgogICAgcmF0aW9fcGF0aCA9IG91dGRpciAvICJzZWdzcGFjZV9yYXRpb3MuY3N2IgogICAgd2l0aCByYXRpb19wYXRoLm9wZW4oInciLCBuZXdsaW5lPSIiLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgIHdyID0gY3N2LndyaXRlcihmKQogICAgICAgIHdyLndyaXRlcm93KFsiY2FzZSIsInJhdGlvX3ZzX0dSIiwiZHpfc2VnIiwiZHpfZ3IiLCJyYXRpb192c19HUipTUiIsImR6X2dyc3IiXSkKICAgICAgICBtYXBfZ3JzciA9IHtjOihyLGRzLGRnKSBmb3IgYyxyLGRzLGRnIGluIHJhdGlvc192c19ncnNyfQogICAgICAgIGZvciBjLCByLCBkcywgZGcgaW4gcmF0aW9zX3ZzX2dyOgogICAgICAgICAgICByMiwgZHMyLCBkZzIgPSBtYXBfZ3Jzci5nZXQoYywgKE5vbmUsTm9uZSxOb25lKSkKICAgICAgICAgICAgd3Iud3JpdGVyb3coW2MsIGYie3I6LjZlfSIsIGYie2RzOi42ZX0iLCBmIntkZzouNmV9IiwKICAgICAgICAgICAgICAgICAgICAgICAgIChmIntyMjouNmV9IiBpZiByMiBpcyBub3QgTm9uZSBlbHNlICIiKSwKICAgICAgICAgICAgICAgICAgICAgICAgIChmIntkZzI6LjZlfSIgaWYgZGcyIGlzIG5vdCBOb25lIGVsc2UgIiIpXSkKICAgIHByaW50KGYiUmF0aW9zLUNTViAgICAgICAgIDoge3JhdGlvX3BhdGh9IikKCiAgICBkZWYgdG9wX2Jsb2NrKHRpdGxlLCBpdGVtcywgdG9wX2spOgogICAgICAgIHByaW50KCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIikKICAgICAgICBwcmludCh0aXRsZSkKICAgICAgICBwcmludCgiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSIpCiAgICAgICAgZm9yIGNhc2UsIHIsIGRzLCBkYiBpbiBpdGVtc1s6dG9wX2tdOgogICAgICAgICAgICBwcmludChmIiAge2Nhc2U6PDI0fSByYXRpbz17cjo4LjNlfSAgfCBkel9zZWc9e2RzOjguM2V9LCBkel9iYXNlPXtkYjo4LjNlfSIpCgogICAgcmF0aW9zX3ZzX2dyLnNvcnQoa2V5PWxhbWJkYSB4OiB4WzFdKQogICAgdG9wX2Jsb2NrKCJUT1Ag4oCTIFNlZyB2cyBHUiAoa2xlaW5lciA9IGJlc3Nlcik6IiwgcmF0aW9zX3ZzX2dyLCB0b3BfaykKICAgIHJhdGlvc192c19nci5zb3J0KGtleT1sYW1iZGEgeDogeFsxXSwgcmV2ZXJzZT1UcnVlKQogICAgdG9wX2Jsb2NrKCJXb3JzdCDigJMgU2VnIHZzIEdSIChncsO2w59lciA9IHNjaGxlY2h0ZXIpOiIsIHJhdGlvc192c19nciwgdG9wX2spCgogICAgcmF0aW9zX3ZzX2dyc3Iuc29ydChrZXk9bGFtYmRhIHg6IHhbMV0pCiAgICB0b3BfYmxvY2soIlRPUCDigJMgU2VnIHZzIEdSKlNSIChrbGVpbmVyID0gYmVzc2VyKToiLCByYXRpb3NfdnNfZ3JzciwgdG9wX2spCiAgICByYXRpb3NfdnNfZ3Jzci5zb3J0KGtleT1sYW1iZGEgeDogeFsxXSwgcmV2ZXJzZT1UcnVlKQogICAgdG9wX2Jsb2NrKCJXb3JzdCDigJMgU2VnIHZzIEdSKlNSIChncsO2w59lciA9IHNjaGxlY2h0ZXIpOiIsIHJhdGlvc192c19ncnNyLCB0b3BfaykKCiAgICBpZiBtYWtlX3Bsb3RzOgogICAgICAgIHRyeToKICAgICAgICAgICAgcGx0ID0gX2xhenlfbWF0cGxvdGxpYigpCiAgICAgICAgICAgIGZvciBrZXksIHRpdGxlIGluIFsoInNlZyIsIlNlZyIpLCgiZ3IiLCJHUiIpLCgic3IiLCJTUiIpLCgiZ3JzciIsIkdSKlNSIildOgogICAgICAgICAgICAgICAgdmVjID0gcGVyX21vZGVsX2Fic1trZXldCiAgICAgICAgICAgICAgICBpZiBub3QgdmVjOiBjb250aW51ZQogICAgICAgICAgICAgICAgcGx0LmZpZ3VyZShmaWdzaXplPSg4LCA1KSkKICAgICAgICAgICAgICAgIHBsdC5oaXN0KHZlYywgYmlucz0yNCwgYWxwaGE9MC43NSkKICAgICAgICAgICAgICAgIHBsdC54bGFiZWwoInzOlHp8Iik7IHBsdC55bGFiZWwoIkNvdW50IikKICAgICAgICAgICAgICAgIHBsdC50aXRsZShmIlJlc2lkdWFsczoge3RpdGxlfSAoTWVkaWFuID0ge3N0YXRzLm1lZGlhbih2ZWMpOi4yZX0pIikKICAgICAgICAgICAgICAgIHBsdC5ncmlkKFRydWUsIGFscGhhPTAuMykKICAgICAgICAgICAgICAgIG91dHAgPSBvdXRkaXIgLyBmImhpc3Rfe2tleX0ucG5nIgogICAgICAgICAgICAgICAgcGx0LnNhdmVmaWcob3V0cCwgZHBpPTE0MCwgYmJveF9pbmNoZXM9InRpZ2h0IikKICAgICAgICAgICAgICAgIHBsdC5jbG9zZSgpCiAgICAgICAgICAgICAgICBwcmludChmIltJTkZPXSBQbG90IHNhdmVkOiB7b3V0cH0iKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZXg6CiAgICAgICAgICAgIHByaW50KGYiW1dBUk5dIHBsb3R0aW5nIGZhaWxlZDoge2V4fSIpCgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiMgQm91bmQtRW5lcmd5ICYgzrEgKEZyZXF1ZW56ZW4pCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KZGVmIGJvdW5kX2VuZXJneV9yb3dzKHBhaXJzOiBMaXN0W1R1cGxlW0QsIEQsIHN0cl1dKSAtPiBMaXN0W2RpY3RdOgogICAgcm93cyA9IFtdCiAgICBmb3IgZl9lbWl0LCBmX29icywgbGFiZWwgaW4gcGFpcnM6CiAgICAgICAgTl9zZWcgPSBmX2VtaXQgLyBmX29icyAtIEQoMSkKICAgICAgICBFX2dhbW1hID0gaCAqIGZfZW1pdAogICAgICAgIGFscGhhX2xvY2FsID0gKGZfb2JzICogaCkgLyAoRCgnOS4xMDkzODM3MDE1ZS0zMScpICogYyoqMikKICAgICAgICBmX2VtaXRfYmFjayA9IChhbHBoYV9sb2NhbCAqIEQoJzkuMTA5MzgzNzAxNWUtMzEnKSAqIGMqKjIpIC8gaAogICAgICAgIHpfZ3IgPSAoZl9lbWl0IC0gZl9vYnMpIC8gZl9vYnMKICAgICAgICByZWxfZXJyb3IgPSBhYnMoZl9lbWl0X2JhY2sgLSBmX2VtaXQpIC8gZl9lbWl0CiAgICAgICAgcm93cy5hcHBlbmQoewogICAgICAgICAgICAibGFiZWwiOiBsYWJlbCwKICAgICAgICAgICAgImZfZW1pdF9IeiI6IGZfZW1pdCwKICAgICAgICAgICAgImZfb2JzX0h6IjogZl9vYnMsCiAgICAgICAgICAgICJOX3NlZyI6IE5fc2VnLAogICAgICAgICAgICAiRV9nYW1tYV9KIjogRV9nYW1tYSwKICAgICAgICAgICAgImFscGhhX2xvY2FsIjogYWxwaGFfbG9jYWwsCiAgICAgICAgICAgICJ6X2dyIjogel9nciwKICAgICAgICAgICAgImZfZW1pdF9iYWNrX2NhbGNfSHoiOiBmX2VtaXRfYmFjaywKICAgICAgICAgICAgInJlbF9lcnJvciI6IHJlbF9lcnJvcgogICAgICAgIH0pCiAgICByZXR1cm4gcm93cwoKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQojIFN1YmNvbW1hbmRzIOKAkyBJbXBsZW1lbnRpZXJ1bmdlbgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCmRlZiBjbWRfcGlfYnJpZGdlKGFyZ3MpOgogICAgIyBQcsOkemlzaW9uIChTdWJjb21tYW5kLWxva2FsIGVybGF1YnQpCiAgICBnZXRjb250ZXh0KCkucHJlYyA9IGludChhcmdzLnByZWMpCgogICAgIyDPgC1CYW5uZXIgKGbDvHIgUHJvdG9rb2xsL1JlcHJvZHV6aWVyYmFya2VpdCkKICAgIGlmIGFyZ3MucGlfc291cmNlID09ICJjaHVkIjoKICAgICAgICBwaSwgbXMgPSBjaHVkbm92c2t5X3BpKGFyZ3MuY2h1ZF90ZXJtcywgYXJncy5wcmVjKQogICAgICAgIHBpX3N0ciA9IHN0cigrcGkpCiAgICAgICAgbXNfc3RyID0gZiJ7bXM6LjNmfSBtcyIKICAgIGVsaWYgYXJncy5waV9zb3VyY2UgPT0gImJ1aWx0aW4iOgogICAgICAgIGltcG9ydCBtYXRoCiAgICAgICAgcGlfc3RyID0gcmVwcihtYXRoLnBpKTsgbXNfc3RyID0gIjAuMDAwIG1zIgogICAgZWxpZiBhcmdzLnBpX3NvdXJjZSA9PSAicGhpIjoKICAgICAgICBwaV9zdHIgPSAicGhpLW1vZGUgKM+AIG5pY2h0IGdlbnV0enQpIjsgbXNfc3RyID0gIjAuMDAwIG1zIgogICAgZWxzZToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKCJpbnZhbGlkIC0tcGktc291cmNlIikKCiAgICBwcmludCgiXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IikKICAgIHByaW50KCIgU0VHTUVOVEVEIFNQQUNFVElNRSDigJMgzpQoTSkgKyBDSFVETk9WU0tZ4oCRz4AgQlJJREdFIChSdW5uZXIpIikKICAgIHByaW50KCI9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IikKICAgIHByaW50KGYiz4AgKHthcmdzLnBpX3NvdXJjZX0pICAgICA6IHtwaV9zdHJbOjEwMF19Li4uIikKICAgIHByaW50KGYiz4AgY29tcHV0ZSB0aW1lICAgICA6IHttc19zdHJ9IikKCiAgICAjIENTViB3w6RobGVuCiAgICBjYW5kID0gW1BhdGgoYXJncy5jc3YpXSBpZiBhcmdzLmNzdiBlbHNlIFtdCiAgICBjYW5kICs9IFtQYXRoKHgpIGZvciB4IGluIFsKICAgICAgICAicmVhbF9kYXRhX2Z1bGwuY3N2IiwKICAgICAgICAicmVhbF9kYXRhXzMwX3NlZ21vZGVsLmNzdiIsCiAgICAgICAgInJlYWxfZGF0YV8zMF9zZWdtb2RlbF9TVFJPTkdfTkVULmNzdiIsCiAgICAgICAgInJlYWxfZGF0YV8zMF9zZWdtb2RlbF9MT0NLRUQuY3N2IiwKICAgIF1dCiAgICBjc3ZfcGF0aCA9IE5vbmUKICAgIGZvciBwIGluIGNhbmQ6CiAgICAgICAgaWYgcCBhbmQgcC5leGlzdHMoKToKICAgICAgICAgICAgY3N2X3BhdGggPSBwOyBicmVhawogICAgaWYgY3N2X3BhdGggaXMgTm9uZToKICAgICAgICBwcmludCgiW0VSUk9SXSBubyBDU1YgZm91bmQuIFVzZSAtLWNzdiBQQVRILiIsIGZpbGU9c3lzLnN0ZGVycikKICAgICAgICBzeXMuZXhpdCgyKQoKICAgIGlmIHBkIGlzIE5vbmU6CiAgICAgICAgcHJpbnQoIltFUlJPUl0gcGFuZGFzIHJlcXVpcmVkLiBwaXAgaW5zdGFsbCBwYW5kYXMiLCBmaWxlPXN5cy5zdGRlcnIpCiAgICAgICAgc3lzLmV4aXQoMykKCiAgICBkZiA9IHBkLnJlYWRfY3N2KGNzdl9wYXRoKQogICAgb3V0ZGlyID0gUGF0aChhcmdzLm91dCkKICAgIG91dGRpci5ta2RpcihwYXJlbnRzPVRydWUsIGV4aXN0X29rPVRydWUpCgogICAgZXZhbHVhdGVfZGF0YXNldCgKICAgICAgICBkZiwKICAgICAgICBwcmVmZXJfej1hcmdzLnByZWZlcl96LAogICAgICAgIHNlZ19tb2RlPWFyZ3Muc2VnX21vZGUsCiAgICAgICAgb3V0ZGlyPW91dGRpciwKICAgICAgICBkbUE9YXJncy5kZWx0YW1fQSwKICAgICAgICBkbUI9YXJncy5kZWx0YW1fQiwKICAgICAgICBkbUFscGhhPWFyZ3MuZGVsdGFtX2FscGhhLAogICAgICAgIGxvZ01fbWluPWFyZ3MubG9nTV9taW4sCiAgICAgICAgbG9nTV9tYXg9YXJncy5sb2dNX21heCwKICAgICAgICBtYWtlX3Bsb3RzPWFyZ3MucGxvdHMsCiAgICAgICAgdG9wX2s9YXJncy50b3AKICAgICkKICAgIHByaW50KGYiRGVidWfigJFDU1YgICAgICAgICAgOiB7b3V0ZGlyLydzZWdzcGFjZV9kZWJ1Zy5jc3YnfSIpCiAgICBwcmludChmIlJhdGlvc+KAkUNTViAgICAgICAgIDoge291dGRpci8nc2Vnc3BhY2VfcmF0aW9zLmNzdid9IikKCmRlZiBjbWRfbWFzc192YWxpZGF0ZShhcmdzKToKICAgIGdldGNvbnRleHQoKS5wcmVjID0gaW50KGFyZ3MucHJlYykKCiAgICBCQVNFID0gewogICAgICAgICdFbGVrdHJvbic6ICAgICAgICBEKCc5LjEwOTM4MzU2ZS0zMScpLAogICAgICAgICdNb25kJzogICAgICAgICAgICBEKCc3LjM0MmUyMicpLAogICAgICAgICdFcmRlJzogICAgICAgICAgICBEKCc1Ljk3MjE5ZTI0JyksCiAgICAgICAgJ1Nvbm5lJzogICAgICAgICAgIE1fc3VuLAogICAgICAgICdTYWdpdHRhcml1cyBBKic6ICBEKCc0LjI5N2U2JykgKiBNX3N1biwKICAgIH0KICAgIGlmIGFyZ3MuZXh0cmFfY3N2IGFuZCBQYXRoKGFyZ3MuZXh0cmFfY3N2KS5leGlzdHMoKToKICAgICAgICB3aXRoIG9wZW4oYXJncy5leHRyYV9jc3YsIG5ld2xpbmU9JycsIGVuY29kaW5nPSd1dGYtOCcpIGFzIGY6CiAgICAgICAgICAgIGZvciByb3cgaW4gY3N2LkRpY3RSZWFkZXIoZik6CiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHJvd1snT2JqZWt0J10KICAgICAgICAgICAgICAgICAgICBtX3N1biA9IEQoc3RyKHJvd1snTV90cnVlX01zdW4nXSkpCiAgICAgICAgICAgICAgICAgICAgQkFTRS5zZXRkZWZhdWx0KG5hbWUsIG1fc3VuICogTV9zdW4pCiAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlCgogICAgbWFzc2VzID0gbGlzdChCQVNFLnZhbHVlcygpKQogICAgTG1pbiwgTG1heCA9IGRtX25vcm1fYm91bmRzKG1hc3NlcykKCiAgICByZXN1bHRzID0gW10KICAgIGZvciBuYW1lLCBNX3RydWUgaW4gQkFTRS5pdGVtcygpOgogICAgICAgIHJfcyAgID0gRCgyKSpHKk1fdHJ1ZS9jKioyCiAgICAgICAgcl9vYnMgPSBCTEMgKiByX3MgKiAoRCgxKSArIGRtX3BlcmNlbnQoTV90cnVlLCBMbWluLCBMbWF4LCBEKHN0cihhcmdzLmRlbHRhbV9BKSksIEQoc3RyKGFyZ3MuZGVsdGFtX2FscGhhKSksIEQoc3RyKGFyZ3MuZGVsdGFtX0IpKSkgLyBEKDEwMCkpCiAgICAgICAgTV9yZWMgPSBpbnZlcnRfbWFzcyhyX29icywgTV90cnVlLCBMbWluLCBMbWF4LCBEKHN0cihhcmdzLmRlbHRhbV9BKSksIEQoc3RyKGFyZ3MuZGVsdGFtX2FscGhhKSksIEQoc3RyKGFyZ3MuZGVsdGFtX0IpKSkKICAgICAgICByZWwgICA9IGFicygoTV9yZWMgLSBNX3RydWUpL01fdHJ1ZSkgKiBEKDEwMCkKICAgICAgICByZXN1bHRzLmFwcGVuZCgobmFtZSwgTV90cnVlLCBNX3JlYywgcmVsKSkKCiAgICBvdXRfY3N2ID0gUGF0aChhcmdzLm91dCBvciAiLiIpIC8gInNlZ21lbnRlZF9zcGFjZXRpbWVfbWFzc192YWxpZGF0aW9uX2Z1bGwuY3N2IgogICAgb3V0X2Nzdi5wYXJlbnQubWtkaXIocGFyZW50cz1UcnVlLCBleGlzdF9vaz1UcnVlKQogICAgd2l0aCBvdXRfY3N2Lm9wZW4oInciLCBuZXdsaW5lPSIiLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgIHcgPSBjc3Yud3JpdGVyKGYpCiAgICAgICAgdy53cml0ZXJvdyhbIk9iamVrdCIsIk1fdHJ1ZV9rZyIsIk1fcmVjX2tnIiwiUmVsRXJyXyUiXSkKICAgICAgICBmb3IgbmFtZSwgTXQsIE1yLCBlcnIgaW4gcmVzdWx0czoKICAgICAgICAgICAgdy53cml0ZXJvdyhbbmFtZSwgZiJ7TXQ6LjZlfSIsIGYie01yOi42ZX0iLCBmIntlcnI6LjNlfSJdKQoKICAgIHByaW50KCJcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0iKQogICAgcHJpbnQoIiBTRUdNRU5URUQgU1BBQ0VUSU1FIOKAkyBNQVNTIFZBTElEQVRJT04iKQogICAgcHJpbnQoIj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0iKQogICAgcHJpbnQoZiJ7J09iamVrdCc6PDIwfSB7J01fdHJ1ZShrZyknOj4xNX0geydNX3JlYyhrZyknOj4xNX0geydSZWxFcnJfJSc6PjEwfSIpCiAgICBwcmludCgiLSIqNjQpCiAgICBmb3IgbmFtZSwgTXQsIE1yLCBlcnIgaW4gcmVzdWx0czoKICAgICAgICBwcmludChmIntuYW1lOjwyMH0ge010OjE1LjZlfSB7TXI6MTUuNmV9IHtmbG9hdChlcnIpOjEwLjNlfSIpCiAgICBwcmludChmIlxuQ1NWIGV4cG9ydCDihpIge291dF9jc3YucmVzb2x2ZSgpfSIpCgpkZWYgY21kX2JvdW5kX2VuZXJneShhcmdzKToKICAgIGdldGNvbnRleHQoKS5wcmVjID0gaW50KGFyZ3MucHJlYykKCiAgICBwYWlyczogTGlzdFtUdXBsZVtELEQsc3RyXV0gPSBbXQogICAgaWYgYXJncy5wYWlycyBhbmQgUGF0aChhcmdzLnBhaXJzKS5leGlzdHMoKToKICAgICAgICAjIENTViBtaXQgU3BhbHRlbjogbGFiZWwsZl9lbWl0X0h6LGZfb2JzX0h6CiAgICAgICAgd2l0aCBvcGVuKGFyZ3MucGFpcnMsIG5ld2xpbmU9JycsIGVuY29kaW5nPSd1dGYtOCcpIGFzIGY6CiAgICAgICAgICAgIGZvciByb3cgaW4gY3N2LkRpY3RSZWFkZXIoZik6CiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSByb3cuZ2V0KCJsYWJlbCIsIj8iKQogICAgICAgICAgICAgICAgICAgIGZfZW1pdCA9IEQoc3RyKHJvd1siZl9lbWl0X0h6Il0pKQogICAgICAgICAgICAgICAgICAgIGZfb2JzICA9IEQoc3RyKHJvd1siZl9vYnNfSHoiXSkpCiAgICAgICAgICAgICAgICAgICAgcGFpcnMuYXBwZW5kKChmX2VtaXQsIGZfb2JzLCBsYWJlbCkpCiAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICBlbHNlOgogICAgICAgICMgRGVtby1EYXRlbgogICAgICAgIHBhaXJzID0gWwogICAgICAgICAgICAoRCgiMS4zODRlMTQiKSwgRCgiMS4zODNlMTQiKSwgIlMyIG5lYXIgU2dyIEEqIiksCiAgICAgICAgICAgIChEKCI0LjU2OGUxNCIpLCBEKCI0LjU2N2UxNCIpLCAiU2lyaXVzIEIiKSwKICAgICAgICAgICAgKEQoIjQuNzU5ZTE0IiksIEQoIjQuNzU5ZTE0IiksICJTdW4gbGluZSIpLAogICAgICAgICAgICAoRCgiMy40ODJlMTgiKSwgRCgiMy40ODJlMTgiKSwgIlBvdW5k4oCTUmVia2EiKSwKICAgICAgICAgICAgKEQoIjQuNTcwZTE0IiksIEQoIjQuNTcwZTE0IiksICJFYXJ0aCBsYWIiKSwKICAgICAgICBdCgogICAgcm93cyA9IGJvdW5kX2VuZXJneV9yb3dzKHBhaXJzKQogICAgb3V0ZGlyID0gUGF0aChhcmdzLm91dCBvciAiLiIpCiAgICBvdXRkaXIubWtkaXIocGFyZW50cz1UcnVlLCBleGlzdF9vaz1UcnVlKQogICAgb3V0X2NzdiA9IG91dGRpciAvICJib3VuZF9lbmVyZ3lfcmVzdWx0cy5jc3YiCiAgICB3aXRoIG91dF9jc3Yub3BlbigidyIsIG5ld2xpbmU9IiIsIGVuY29kaW5nPSJ1dGYtOCIpIGFzIGY6CiAgICAgICAgdyA9IGNzdi53cml0ZXIoZikKICAgICAgICB3LndyaXRlcm93KFsibGFiZWwiLCJmX2VtaXRfSHoiLCJmX29ic19IeiIsIk5fc2VnIiwiRV9nYW1tYV9KIiwiYWxwaGFfbG9jYWwiLCJ6X2dyIiwiZl9lbWl0X2JhY2tfY2FsY19IeiIsInJlbF9lcnJvciJdKQogICAgICAgIGZvciByIGluIHJvd3M6CiAgICAgICAgICAgIHcud3JpdGVyb3coWwogICAgICAgICAgICAgICAgclsibGFiZWwiXSwKICAgICAgICAgICAgICAgIGYie3JbJ2ZfZW1pdF9IeiddOi42RX0iLAogICAgICAgICAgICAgICAgZiJ7clsnZl9vYnNfSHonXTouNkV9IiwKICAgICAgICAgICAgICAgIGYie3JbJ05fc2VnJ106LjEyRX0iLAogICAgICAgICAgICAgICAgZiJ7clsnRV9nYW1tYV9KJ106LjEyRX0iLAogICAgICAgICAgICAgICAgZiJ7clsnYWxwaGFfbG9jYWwnXTouMTJFfSIsCiAgICAgICAgICAgICAgICBmIntyWyd6X2dyJ106LjEyRX0iLAogICAgICAgICAgICAgICAgZiJ7clsnZl9lbWl0X2JhY2tfY2FsY19IeiddOi42RX0iLAogICAgICAgICAgICAgICAgZiJ7clsncmVsX2Vycm9yJ106LjZFfSIsCiAgICAgICAgICAgIF0pCgogICAgcHJpbnQoIlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSIpCiAgICBwcmludCgiIFNFR01FTlRFRCBTUEFDRVRJTUUg4oCTIEJPVU5EIEVORVJHWSAvIExPQ0FMIM6xIikKICAgIHByaW50KCI9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IikKICAgIGZvciByIGluIHJvd3M6CiAgICAgICAgcHJpbnQoZiJcbi0tLSB7clsnbGFiZWwnXX0gLS0tIikKICAgICAgICBwcmludChmImZfZW1pdCAgICA6IHtyWydmX2VtaXRfSHonXTouNkV9IEh6IikKICAgICAgICBwcmludChmImZfb2JzICAgICA6IHtyWydmX29ic19IeiddOi42RX0gSHoiKQogICAgICAgIHByaW50KGYiTl9zZWcgICAgIDoge3JbJ05fc2VnJ106LjEyRX0iKQogICAgICAgIHByaW50KGYiRV9nYW1tYSAgIDoge3JbJ0VfZ2FtbWFfSiddOi4xMkV9IEoiKQogICAgICAgIHByaW50KGYiYWxwaGFfbG9jIDoge3JbJ2FscGhhX2xvY2FsJ106LjEyRX0iKQogICAgICAgIHByaW50KGYiel9nciAgICAgIDoge3JbJ3pfZ3InXTouMTJFfSIpCiAgICAgICAgcHJpbnQoZiJmX2VtaXTihpDOsSAgOiB7clsnZl9lbWl0X2JhY2tfY2FsY19IeiddOi42RX0gSHoiKQogICAgICAgIHByaW50KGYicmVsX2Vycm9yIDoge3JbJ3JlbF9lcnJvciddOi42RX0iKQoKICAgIHByaW50KGYiXG5DU1YgZXhwb3J0IOKGkiB7b3V0X2Nzdi5yZXNvbHZlKCl9IikKCiAgICBpZiBhcmdzLnBsb3Q6CiAgICAgICAgdHJ5OgogICAgICAgICAgICBwbHQgPSBfbGF6eV9tYXRwbG90bGliKCkKICAgICAgICAgICAgeHMgPSBsaXN0KHJhbmdlKDEsIGxlbihyb3dzKSsxKSkKICAgICAgICAgICAgZXJycyA9IFtmbG9hdChyWyJyZWxfZXJyb3IiXSkgZm9yIHIgaW4gcm93c10KICAgICAgICAgICAgbGFiZWxzID0gW3JbImxhYmVsIl0gZm9yIHIgaW4gcm93c10KICAgICAgICAgICAgcGx0LmZpZ3VyZShmaWdzaXplPSg5LDUpKQogICAgICAgICAgICBwbHQucGxvdCh4cywgZXJycywgbWFya2VyPSdvJykKICAgICAgICAgICAgZm9yIGksIHR4dCBpbiBlbnVtZXJhdGUobGFiZWxzKToKICAgICAgICAgICAgICAgIHBsdC5hbm5vdGF0ZSh0eHQsICh4c1tpXSwgZXJyc1tpXSksIGZvbnRzaXplPTgsIHh5dGV4dD0oNCw1KSwgdGV4dGNvb3Jkcz0nb2Zmc2V0IHBvaW50cycpCiAgICAgICAgICAgIHBsdC54bGFiZWwoIlNvdXJjZSBJRCIpCiAgICAgICAgICAgIHBsdC55bGFiZWwoIlJlbGF0aXZlIEVycm9yIG9mIGZfZW1pdCBiYWNrLWNhbGMiKQogICAgICAgICAgICBwbHQuZ3JpZChUcnVlLCBhbHBoYT0wLjQpCiAgICAgICAgICAgIG91dF9wbmcgPSBvdXRkaXIgLyAiYm91bmRfZW5lcmd5X3JlbF9lcnJvci5wbmciCiAgICAgICAgICAgIHBsdC50aWdodF9sYXlvdXQoKTsgcGx0LnNhdmVmaWcob3V0X3BuZywgZHBpPTE0MCkKICAgICAgICAgICAgcHJpbnQoZiJQbG90IHNhdmVkIOKGkiB7b3V0X3BuZy5yZXNvbHZlKCl9IikKICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGV4OgogICAgICAgICAgICBwcmludChmIltXQVJOXSBwbG90dGluZyBmYWlsZWQ6IHtleH0iKQoKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQojIENMSQojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCmRlZiBtYWluKCk6CiAgICBhcCA9IGFyZ3BhcnNlLkFyZ3VtZW50UGFyc2VyKGRlc2NyaXB0aW9uPSJTRUdTUEFDRSDigJMgQWxsLWluLU9uZSBUb29sa2l0IikKICAgICMgR2xvYmFsIC0tcHJlYyAoZmFsbHMgVk9SIGRlbSBTdWJjb21tYW5kIHZlcndlbmRldCB3aXJkKQogICAgYXAuYWRkX2FyZ3VtZW50KCItLXByZWMiLCB0eXBlPWludCwgZGVmYXVsdD04MCwgaGVscD0iRGVjaW1hbCBwcmVjaXNpb24gKGdsb2JhbCwgZGVmYXVsdCA4MCkiKQoKICAgIHN1YiA9IGFwLmFkZF9zdWJwYXJzZXJzKGRlc3Q9ImNtZCIsIHJlcXVpcmVkPVRydWUpCgogICAgIyDPgC1CcmlkZ2UgLyBFdmFsdWF0b3IKICAgIGFwX3BpID0gc3ViLmFkZF9wYXJzZXIoInBpLWJyaWRnZSIsIGhlbHA9IlJ1biDPgC1CcmlkZ2UgKyBEYXRhc2V0IEV2YWx1YXRpb24iKQogICAgYXBfcGkuYWRkX2FyZ3VtZW50KCItLXByZWMiLCB0eXBlPWludCwgZGVmYXVsdD0yMDAsIGhlbHA9IkRlY2ltYWwgcHJlY2lzaW9uIGZvciB0aGlzIHN1YmNvbW1hbmQiKQogICAgYXBfcGkuYWRkX2FyZ3VtZW50KCItLWNzdiIsIHR5cGU9c3RyLCBkZWZhdWx0PU5vbmUsIGhlbHA9IklucHV0IENTViAoYXV0by1kZXRlY3QgZmFsbGJhY2spIikKICAgIGFwX3BpLmFkZF9hcmd1bWVudCgiLS1vdXQiLCB0eXBlPXN0ciwgZGVmYXVsdD0ic2Vnc3BhY2VfcGlfYnJpZGdlX291dCIsIGhlbHA9Ik91dHB1dCBkaXJlY3RvcnkiKQogICAgYXBfcGkuYWRkX2FyZ3VtZW50KCItLXNlZy1tb2RlIiwgdHlwZT1zdHIsIGRlZmF1bHQ9Imh5YnJpZCIsIGNob2ljZXM9WyJoaW50IiwiZGVsdGFNIiwiaHlicmlkIiwiZ3JzciJdLCBoZWxwPSJTZWdtZW50IG1vZGVsIikKICAgIGFwX3BpLmFkZF9hcmd1bWVudCgiLS1uby1lbWlzc2lvbi1nYXRlIiwgYWN0aW9uPSJzdG9yZV90cnVlIiwgaGVscD0iRGlzYWJsZSBlbWlzc2lvbi1jbGFzcyBnYXRpbmcgKGpldHMvcHVsc2Fycy9CTCBMYWNzL0FHTuKGkkdSKlNSKSIpCiAgICBhcF9waS5hZGRfYXJndW1lbnQoIi0tcHJlZmVyLXoiLCBhY3Rpb249InN0b3JlX3RydWUiLCBoZWxwPSJQcmVmZXIgJ3onIGNvbHVtbiBvdmVyIGZfZW1pdC9mX29icyIpCiAgICBhcF9waS5hZGRfYXJndW1lbnQoIi0tZGVsdGFtLUEiLCB0eXBlPWZsb2F0LCBkZWZhdWx0PTk4LjAxLCBoZWxwPSLOlChNKSBBIGluIHBlcmNlbnQiKQogICAgYXBfcGkuYWRkX2FyZ3VtZW50KCItLWRlbHRhbS1CIiwgdHlwZT1mbG9hdCwgZGVmYXVsdD0xLjk2LCBoZWxwPSLOlChNKSBCIGluIHBlcmNlbnQiKQogICAgYXBfcGkuYWRkX2FyZ3VtZW50KCItLWRlbHRhbS1hbHBoYSIsIHR5cGU9ZmxvYXQsIGRlZmF1bHQ9MjcxNzcuMCwgaGVscD0izpQoTSkgYWxwaGEgWzEvbV0iKQogICAgYXBfcGkuYWRkX2FyZ3VtZW50KCItLWxvZ00tbWluIiwgdHlwZT1mbG9hdCwgZGVmYXVsdD1Ob25lLCBoZWxwPSJPdmVycmlkZSBtaW4obG9nMTAgTSkiKQogICAgYXBfcGkuYWRkX2FyZ3VtZW50KCItLWxvZ00tbWF4IiwgdHlwZT1mbG9hdCwgZGVmYXVsdD1Ob25lLCBoZWxwPSJPdmVycmlkZSBtYXgobG9nMTAgTSkiKQogICAgYXBfcGkuYWRkX2FyZ3VtZW50KCItLXBsb3RzIiwgYWN0aW9uPSJzdG9yZV90cnVlIiwgaGVscD0iQ3JlYXRlIHJlc2lkdWFsIGhpc3RvZ3JhbXMiKQogICAgYXBfcGkuYWRkX2FyZ3VtZW50KCItLXRvcCIsIHR5cGU9aW50LCBkZWZhdWx0PTEwLCBoZWxwPSJUb3AgSyBpbiBCZXN0L1dvcnN0IGxpc3RzIikKICAgIGFwX3BpLmFkZF9hcmd1bWVudCgiLS1waS1zb3VyY2UiLCB0eXBlPXN0ciwgZGVmYXVsdD0iY2h1ZCIsIGNob2ljZXM9WyJjaHVkIiwiYnVpbHRpbiIsInBoaSJdLCBoZWxwPSLPgCBzb3VyY2UgZm9yIGJhbm5lciIpCiAgICBhcF9waS5hZGRfYXJndW1lbnQoIi0tY2h1ZC10ZXJtcyIsIHR5cGU9aW50LCBkZWZhdWx0PTE2LCBoZWxwPSJDaHVkbm92c2t5IHRlcm1zIikKICAgIGFwX3BpLnNldF9kZWZhdWx0cyhmdW5jPWNtZF9waV9icmlkZ2UpCgogICAgIyBNYXNzIHZhbGlkYXRlCiAgICBhcF9tdiA9IHN1Yi5hZGRfcGFyc2VyKCJtYXNzLXZhbGlkYXRlIiwgaGVscD0iVmFsaWRhdGUgzpQoTSkgbWFzcyBpbnZlcnNpb24iKQogICAgYXBfbXYuYWRkX2FyZ3VtZW50KCItLXByZWMiLCB0eXBlPWludCwgZGVmYXVsdD0yMDAsIGhlbHA9IkRlY2ltYWwgcHJlY2lzaW9uIGZvciB0aGlzIHN1YmNvbW1hbmQiKQogICAgYXBfbXYuYWRkX2FyZ3VtZW50KCItLWV4dHJhLWNzdiIsIHR5cGU9c3RyLCBkZWZhdWx0PU5vbmUsIGhlbHA9Ik9wdGlvbmFsIENTViB3aXRoIGNvbHVtbnM6IE9iamVrdCxNX3RydWVfTXN1biIpCiAgICBhcF9tdi5hZGRfYXJndW1lbnQoIi0tb3V0IiwgdHlwZT1zdHIsIGRlZmF1bHQ9InNlZ3NwYWNlX21hc3Nfb3V0IiwgaGVscD0iT3V0cHV0IGRpcmVjdG9yeSIpCiAgICBhcF9tdi5hZGRfYXJndW1lbnQoIi0tZGVsdGFtLUEiLCB0eXBlPWZsb2F0LCBkZWZhdWx0PTk4LjAxKQogICAgYXBfbXYuYWRkX2FyZ3VtZW50KCItLWRlbHRhbS1CIiwgdHlwZT1mbG9hdCwgZGVmYXVsdD0xLjk2KQogICAgYXBfbXYuYWRkX2FyZ3VtZW50KCItLWRlbHRhbS1hbHBoYSIsIHR5cGU9ZmxvYXQsIGRlZmF1bHQ9MjcxNzcuMCkKICAgIGFwX212LnNldF9kZWZhdWx0cyhmdW5jPWNtZF9tYXNzX3ZhbGlkYXRlKQoKICAgICMgQm91bmQgZW5lcmd5CiAgICBhcF9iZSA9IHN1Yi5hZGRfcGFyc2VyKCJib3VuZC1lbmVyZ3kiLCBoZWxwPSJDb21wdXRlIGJvdW5kIGVuZXJneSAmIGxvY2FsIM6xIGZyb20gZnJlcXVlbmN5IHBhaXJzIikKICAgIGFwX2JlLmFkZF9hcmd1bWVudCgiLS1wcmVjIiwgdHlwZT1pbnQsIGRlZmF1bHQ9MjAwLCBoZWxwPSJEZWNpbWFsIHByZWNpc2lvbiBmb3IgdGhpcyBzdWJjb21tYW5kIikKICAgIGFwX2JlLmFkZF9hcmd1bWVudCgiLS1wYWlycyIsIHR5cGU9c3RyLCBkZWZhdWx0PU5vbmUsIGhlbHA9IkNTVjogbGFiZWwsZl9lbWl0X0h6LGZfb2JzX0h6IikKICAgIGFwX2JlLmFkZF9hcmd1bWVudCgiLS1vdXQiLCB0eXBlPXN0ciwgZGVmYXVsdD0iYm91bmRfZW5lcmd5X291dCIsIGhlbHA9Ik91dHB1dCBkaXJlY3RvcnkiKQogICAgYXBfYmUuYWRkX2FyZ3VtZW50KCItLXBsb3QiLCBhY3Rpb249InN0b3JlX3RydWUiLCBoZWxwPSJQbG90IHJlbGF0aXZlIGVycm9yIG9mIGZfZW1pdCBiYWNrLWNhbGMiKQogICAgYXBfYmUuc2V0X2RlZmF1bHRzKGZ1bmM9Y21kX2JvdW5kX2VuZXJneSkKCiAgICBhcmdzID0gYXAucGFyc2VfYXJncygpCgogICAgIyBGYWxscyAtLXByZWMgTlVSIGdsb2JhbCDDvGJlcmdlYmVuIHd1cmRlICh2b3IgU3ViY29tbWFuZCk6IGFud2VuZGVuLgogICAgZ2V0Y29udGV4dCgpLnByZWMgPSBpbnQoZ2V0YXR0cihhcmdzLCAicHJlYyIsIDgwKSkKCiAgICAjIFN1YmNvbW1hbmQgYXVzZsO8aHJlbgogICAgYXJncy5mdW5jKGFyZ3MpCgppZiBfX25hbWVfXyA9PSAiX19tYWluX18iOgogICAgbWFpbigp"""

def load_original_namespace() -> Dict[str, Any]:
    echo_section("LOAD ORIGINAL (EMBEDDED)")
    try:
        src = base64.b64decode(ORIGINAL_CODE_B64.encode("ascii")).decode("utf-8", errors="replace")
        ns = {"__name__":"__segspace_original__","__file__":"<embedded:segspace_all_in_one.py>"}
        exec(src, ns, ns)
        echo("[OK] original code loaded to namespace (no __main__)")
        return ns
    except Exception as e:
        echo(f"[ERR] cannot load original: {e}"); return {}

def workflow_validate_masses(cfg: PreflightConfig) -> int:
    echo_section("WORKFLOW: MASS VALIDATION")
    BASE = {
        'Elektron':        D('9.10938356e-31'),
        'Mond':            D('7.342e22'),
        'Erde':            D('5.97219e24'),
        'Sonne':           M_sun,
        'Sagittarius A*':  D('4.297e6')*M_sun,
    }
    import math as _m
    logs = [D(str(_m.log10(float(m)))) for m in BASE.values()]
    Lmin, Lmax = min(logs), max(logs); rows = []
    for name, M_true in BASE.items():
        rs = (D(2)*G*M_true)/(c**D(2))
        d_pct = delta_percent(M_true, Lmin, Lmax)
        r_obs = (phi/D(2)) * rs * (D(1) + d_pct/D(100))
        M_rec = invert_mass(r_obs, M_true, Lmin, Lmax)
        rel = abs((M_rec - M_true) / M_true)
        echo(f"{name:>14} | M_true={M_true} kg | r_obs={r_obs} m | M_rec={M_rec} kg | rel={rel}")
        rows.append({"object":name,"M_true_kg":f"{M_true}","r_obs_m":f"{r_obs}","M_rec_kg":f"{M_rec}","rel_err":f"{rel}"})
    write_csv(cfg.reports_dir / "mass_validation.csv", rows); return 0

def workflow_eval_redshift(cfg: PreflightConfig, csv_path: Path, prefer_z: bool, mode: str,
                           dmA: float, dmB: float, dmAlpha: float,
                           lo: Optional[float], hi: Optional[float]) -> int:
    echo_section("WORKFLOW: REDSHIFT EVAL")
    if not csv_path.exists(): echo(f"[ERR] CSV not found: {csv_path}"); return 2
    rows = load_csv(csv_path)
    out = evaluate_redshift(rows, prefer_z=prefer_z, mode=mode, dmA=dmA, dmB=dmB, dmAlpha=dmAlpha, lo=lo, hi=hi)
    write_json(cfg.reports_dir / "redshift_medians.json", out["med"])
    write_csv(cfg.reports_dir / "redshift_debug.csv", out["dbg"]); return 0

def workflow_bound_energy(cfg: PreflightConfig) -> int:
    echo_section("WORKFLOW: BOUND ENERGY & α")
    m_e = D('9.10938356e-31')
    E_bound = alpha_fs * m_e * (c**D(2))
    f_thr = E_bound / h
    lam = h / (alpha_fs * m_e * c)
    echo(f"E_bound = {E_bound} J | f_thr = {f_thr} Hz | lambda = {lam} m")
    write_text(cfg.reports_dir / "bound_energy.txt", f"E_bound={E_bound}\n f_thr={f_thr} Hz\n lambda={lam} m\n"); return 0

def workflow_use_original(cfg: PreflightConfig) -> int:
    ns = load_original_namespace()
    keys = ", ".join(sorted(ns.keys())[:60])
    write_text(cfg.reports_dir / "original_namespace_keys.txt", "\n".join(sorted(ns.keys())))
    echo(f"Original namespace keys (first 60): {keys}")
    return 0

def workflow_all(cfg: PreflightConfig, csv_path: Optional[Path]) -> int:
    rc = workflow_validate_masses(cfg)
    if rc != 0: return rc
    if csv_path and csv_path.exists():
        rc = workflow_eval_redshift(cfg, csv_path, prefer_z=True, mode="hybrid",
                                    dmA=float(A), dmB=float(B), dmAlpha=float(ALPHA),
                                    lo=None, hi=None)
        if rc != 0: return rc
    rc = workflow_bound_energy(cfg)
    return rc

def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(prog="segspace_all_in_one_FINAL", description="All-in-one runner for Segmented Spacetime (verbose).")
    p.add_argument("--outdir", type=Path, default=Path("./agent_out"), help="Output root directory")
    p.add_argument("--seed", type=int, default=137, help="Deterministic seed")
    sub = p.add_subparsers(dest="cmd", required=True)
    sub.add_parser("validate-masses", help="Reconstruct masses from segmented radii")
    sp = sub.add_parser("eval-redshift", help="Evaluate GR/SR/Seg models against a dataset")
    sp.add_argument("--csv", type=Path, default=Path("./real_data_full.csv"))
    sp.add_argument("--prefer-z", action="store_true")
    sp.add_argument("--mode", choices=["hint","deltaM","hybrid"], default="hybrid")
    sp.add_argument("--dmA", type=float, default=float(A))
    sp.add_argument("--dmB", type=float, default=float(B))
    sp.add_argument("--dmAlpha", type=float, default=float(ALPHA))
    sp.add_argument("--lo", type=float, default=None)
    sp.add_argument("--hi", type=float, default=None)
    sub.add_parser("bound-energy", help="Compute bound energy thresholds (α)")
    sub.add_parser("use-original", help="Load & introspect embedded original code")
    sub.add_parser("all", help="Run everything (if CSV present)")
    return p

def main(argv: Optional[List[str]] = None) -> int:
    echo_section("SEGSPACE ALL-IN-ONE (FINAL) – START")
    ap = build_parser(); args = ap.parse_args(argv)
    setup_determinism(args.seed)
    cfg = PreflightConfig(outdir=args.outdir, data_dir=args.outdir/"data", figures_dir=args.outdir/"figures",
                          reports_dir=args.outdir/"reports", logs_dir=args.outdir/"logs", manifest_path=args.outdir/"MANIFEST.json")
    safety_preflight(cfg)
    write_json(cfg.manifest_path, {"generated_at": datetime.now().isoformat(timespec="seconds"),
                                   "seed": args.seed, "original_sha256": ORIGINAL_CODE_SHA256})
    if args.cmd == "validate-masses": return workflow_validate_masses(cfg)
    if args.cmd == "eval-redshift":   return workflow_eval_redshift(cfg, args.csv, args.prefer_z, args.mode, args.dmA, args.dmB, args.dmAlpha, args.lo, args.hi)
    if args.cmd == "bound-energy":    return workflow_bound_energy(cfg)
    if args.cmd == "use-original":    return workflow_use_original(cfg)
    if args.cmd == "all":
        csv_path = Path("./real_data_full.csv")
        return workflow_all(cfg, csv_path if csv_path.exists() else None)
    echo(f"[ERR] unknown cmd: {args.cmd}"); return 2

if __name__ == "__main__":
    sys.exit(main())

# ──────────────────────────────────────────────────────────────────────────────
# APPENDIX (commented original for archival)
# ──────────────────────────────────────────────────────────────────────────────
#| #!/usr/bin/env python3
#| # -*- coding: utf-8 -*-
#| from __future__ import annotations
#| 
#| """
#| SEGSPACE – All-in-One Toolkit
#| =============================
#| 
#| Funktionen:
#|   • π-Bridge (Chudnovsky/builtin/phi) + Dataset-Evaluator (Seg vs GR/SR/GR*SR)
#|   • Δ(M)-Massenvalidierung mit Newton-Inversion (high-precision Decimal)
#|   • Bound-Energy & lokale Feinstruktur-α aus Frequenzpaaren (+ optionaler Plot)
#| 
#| Wichtig:
#|   - --prec wird global UND pro Subcommand akzeptiert.
#|   - pandas ist für pi-bridge erforderlich; matplotlib nur für Plots.
#| """
#| 
#| import argparse, csv, math, sys, time, statistics as stats, hashlib, textwrap
#| from dataclasses import dataclass
#| from pathlib import Path
#| from typing import Optional, Tuple, List, Dict
#| 
#| # -----------------------------
#| # Optional Libraries
#| # -----------------------------
#| try:
#|     import pandas as pd
#| except Exception:
#|     pd = None
#| 
#| def _lazy_matplotlib():
#|     import matplotlib.pyplot as plt
#|     return plt
#| 
#| # -----------------------------
#| # Numerik / Konstanten
#| # -----------------------------
#| from decimal import Decimal as D, getcontext
#| 
#| # Default-Precision (kann via CLI global oder pro Subcommand gesetzt werden)
#| getcontext().prec = 80
#| 
#| G     = D('6.67430e-11')       # m^3 kg^-1 s^-2
#| c     = D('2.99792458e8')      # m s^-1
#| h     = D('6.62607015e-34')    # J s
#| M_sun = D('1.98847e30')
#| 
#| phi   = (D(1) + D(5).sqrt()) / D(2)      # goldene Zahl ~1.618...
#| BLC   = phi / D(2)                       # φ/2 ~ 0.809017...
#| 
#| # Δ(M)-Standardparameter (Paper Defaults)
#| DM_A     = D('98.01')        # %
#| DM_ALPHA = D('2.7177e4')     # 1/m
#| DM_B     = D('1.96')         # %
#| TOL      = D('1e-120')
#| 
#| # -----------------------------
#| # Utils
#| # -----------------------------
#| def d(x) -> Optional[D]:
#|     if x is None: return None
#|     try:
#|         xs = str(x).strip()
#|         if xs == "": return None
#|         return D(xs)
#|     except Exception:
#|         return None
#| 
#| def f2(x, default=None):
#|     try:
#|         if x is None: return default
#|         xs = str(x).strip()
#|         if xs == "": return default
#|         return float(xs)
#|     except Exception:
#|         return default
#| 
#| def sha256_file(path: Path) -> str:
#|     h = hashlib.sha256()
#|     with path.open('rb') as f:
#|         for chunk in iter(lambda: f.read(8192), b''):
#|             h.update(chunk)
#|     return h.hexdigest()
#| 
#| # -----------------------------
#| # Chudnovsky-π
#| # -----------------------------
#| def chudnovsky_pi(terms: int, prec: int) -> Tuple[D, float]:
#|     """Compute π via Chudnovsky series with 'terms' and Decimal precision 'prec'."""
#|     from decimal import getcontext
#|     old = getcontext().prec
#|     getcontext().prec = prec
#|     start = time.perf_counter()
#| 
#|     C = 426880 * D(10005).sqrt()
#|     M = D(1); L = D(13591409); X = D(1); K = D(6); S = L
#|     for _k in range(1, terms):
#|         M = (M * (K**3 - 16*K)) / (D(_k)**3)
#|         L += 545140134
#|         X *= -262537412640768000
#|         S += (M * L) / X
#|         K += 12
#| 
#|     pi = C / S
#|     dt = (time.perf_counter() - start) * 1000.0  # ms
#|     getcontext().prec = old
#|     return +pi, dt
#| 
#| # -----------------------------
#| # Orbital/Redshift Physik
#| # -----------------------------
#| def deg2rad(dg): return dg * math.pi / 180.0
#| 
#| def r_from_orbit(a_m, e, f_true_rad):
#|     denom = (1.0 + e*math.cos(f_true_rad))
#|     if denom == 0: return float('nan')
#|     return a_m * (1.0 - e*e) / denom
#| 
#| def vis_viva(mu, a_m, r_m):
#|     term = mu * (2.0/max(r_m, 1e-99) - 1.0/max(a_m, 1e-99))
#|     return math.sqrt(term) if term >= 0.0 else float('nan')
#| 
#| def z_gravitational(M_central_kg: float, r_m: float) -> float:
#|     if not (M_central_kg > 0 and r_m and math.isfinite(r_m) and r_m > 0): return float('nan')
#|     rs = 2.0 * float(G) * M_central_kg / (float(c)**2)
#|     if r_m <= rs: return float('nan')
#|     return 1.0 / math.sqrt(1.0 - rs/r_m) - 1.0
#| 
#| def z_special_rel(v_tot_mps: float, v_los_mps: float = 0.0) -> float:
#|     if v_tot_mps is None or not math.isfinite(v_tot_mps): return float('nan')
#|     v_tot_abs = abs(v_tot_mps)
#|     if v_tot_abs <= 0: return float('nan')
#|     c_f = float(c)
#|     beta = min(v_tot_abs / c_f, 0.999999999999)
#|     beta_los = 0.0 if v_los_mps is None or (not math.isfinite(v_los_mps)) else (v_los_mps / c_f)
#|     gamma = 1.0 / math.sqrt(1.0 - beta*beta)
#|     return gamma * (1.0 + beta_los) - 1.0
#| 
#| def z_combined(z_gr: float, z_sr: float) -> float:
#|     zgr = 0.0 if (z_gr is None or not math.isfinite(z_gr)) else z_gr
#|     zsr = 0.0 if (z_sr is None or not math.isfinite(z_sr)) else z_sr
#|     return (1.0 + zgr) * (1.0 + zsr) - 1.0
#| 
#| def observed_z(row: dict, prefer_z: bool) -> Tuple[Optional[float], str]:
#|     z_direct = f2(row.get("z"))
#|     f_emit   = f2(row.get("f_emit_Hz"))
#|     f_obs    = f2(row.get("f_obs_Hz"))
#|     if prefer_z and z_direct is not None:
#|         return z_direct, "z"
#|     if (f_emit is not None) and (f_obs is not None) and (f_obs != 0.0):
#|         return (f_emit / f_obs - 1.0), "freq"
#|     return z_direct, ("z" if z_direct is not None else "missing")
#| 
#| # -----------------------------
#| # Δ(M)-Modell & Inversion
#| # -----------------------------
#| def dm_raw(M: D, A: D = DM_A, alpha: D = DM_ALPHA, B: D = DM_B) -> D:
#|     rs = (D(2) * G * M) / (c**2)
#|     return A * (-(alpha*rs)).exp() + B
#| 
#| def dm_norm_bounds(masses: List[D]) -> Tuple[D, D]:
#|     logs = [D(str(math.log10(m))) for m in masses if m > 0]
#|     if not logs: return D('0'), D('1')
#|     Lmin, Lmax = min(logs), max(logs)
#|     if Lmax <= Lmin:
#|         Lmin, Lmax = Lmin - D('0.5'), Lmin + D('0.5')
#|     return Lmin, Lmax
#| 
#| def dm_percent(M: D, Lmin: D, Lmax: D, A: D = DM_A, alpha: D = DM_ALPHA, B: D = DM_B) -> D:
#|     if M <= 0: return D(0)
#|     norm = (D(str(math.log10(M))) - Lmin) / (Lmax - Lmin)
#|     norm = max(D(0), min(D(1), norm))
#|     return dm_raw(M, A, alpha, B) * norm
#| 
#| def rphi_from_mass(M: D) -> D:
#|     return (G * M / (c**2)) * phi
#| 
#| def mass_from_rphi(r_phi: D) -> D:
#|     return (c**2) * r_phi / (G * phi)
#| 
#| def f_mass_eq(M: D, r_obs: D, Lmin: D, Lmax: D,
#|               A: D = DM_A, alpha: D = DM_ALPHA, B: D = DM_B) -> D:
#|     return (G*phi*M/c**2) * (D(1) + dm_percent(M, Lmin, Lmax, A, alpha, B)/D(100)) - r_obs
#| 
#| def df_dM(M: D, r_obs: D, Lmin: D, Lmax: D,
#|           A: D = DM_A, alpha: D = DM_ALPHA, B: D = DM_B) -> D:
#|     h = M * D('1e-25') if M != 0 else D('1e-25')
#|     return (f_mass_eq(M+h, r_obs, Lmin, Lmax, A, alpha, B) - f_mass_eq(M-h, r_obs, Lmin, Lmax, A, alpha, B)) / (D(2)*h)
#| 
#| def invert_mass(r_obs: D, M0: D, Lmin: D, Lmax: D,
#|                 A: D = DM_A, alpha: D = DM_ALPHA, B: D = DM_B) -> D:
#|     M = max(M0, D('1e-50'))
#|     for _ in range(200):
#|         y = f_mass_eq(M, r_obs, Lmin, Lmax, A, alpha, B)
#|         if abs(y) < TOL: break
#|         step = -y / df_dM(M, r_obs, Lmin, Lmax, A, alpha, B)
#|         while abs(step) > abs(M):
#|             step *= D('0.5')
#|         M += step
#|         if abs(step / M) < TOL: break
#|     return M
#| 
#| # -----------------------------
#| # Seg-Modell (Hint / ΔM / Hybrid)
#| # -----------------------------
#| def z_seg_hint(row: dict, z_sr: float, z_grsr: float) -> float:
#|     z_hint = f2(row.get("z_geom_hint"))
#|     if z_hint is not None and math.isfinite(z_hint):
#|         return z_combined(z_hint, z_sr)
#|     return z_grsr
#| 
#| def z_seg_deltam(row: dict, z_gr: float, z_sr: float,
#|                  A: float, B: float, alpha_m: float,
#|                  logM_min: Optional[float], logM_max: Optional[float],
#|                  dataset_Lmin: Optional[float], dataset_Lmax: Optional[float]) -> float:
#|     Msun = f2(row.get("M_solar"))
#|     if Msun is None or not math.isfinite(Msun) or Msun <= 0:
#|         return z_combined(z_gr, z_sr)
#|     M = Msun * float(M_sun)
#|     rs = 2.0 * float(G) * M / (float(c)**2)
#|     lM = math.log10(M)
#|     lo = (logM_min if (logM_min is not None) else dataset_Lmin)
#|     hi = (logM_max if (logM_max is not None) else dataset_Lmax)
#|     if (lo is None) or (hi is None) or (hi <= lo):
#|         lo, hi = lM - 0.5, lM + 0.5
#|     norm = (lM - lo) / (hi - lo)
#|     norm = min(1.0, max(0.0, norm))
#|     delta_pct = (A * math.exp(-alpha_m * rs) + B) * norm
#|     z_gr_scaled = z_gr * (1.0 + delta_pct/100.0)
#|     return z_combined(z_gr_scaled, z_sr)
#| 
#| def z_seg(row: dict, mode: str, z_gr: float, z_sr: float, z_grsr: float,
#|           dmA: float, dmB: float, dmAlpha: float,
#|           logM_min: Optional[float], logM_max: Optional[float],
#|           dataset_Lmin: Optional[float], dataset_Lmax: Optional[float],
#|           use_emission_gate: bool = True) -> float:
#|     if mode == "hint":
#|         return z_seg_hint(row, z_sr, z_grsr)
#|     elif mode == "deltaM":
#|         return z_seg_deltam(row, z_gr, z_sr, dmA, dmB, dmAlpha,
#|                             logM_min, logM_max, dataset_Lmin, dataset_Lmax)
#|     elif mode == "hybrid":
#|         z_hint = f2(row.get("z_geom_hint"))
#|         case = str(row.get("case","")).lower()
#|         category = str(row.get("category","")).lower()
#|         # Beispiel-Heuristik: S-Sterne nutzen Hint, sonst ΔM
#|         # Optionales Emissions-Gate: nur wenn aktiviert
#|         if use_emission_gate:
#|             bad_for_deltaM = ("jet","psr","pulsar","bl_lac","3c","agn","quasar")
#|             if any((t in case) or (t in category) for t in bad_for_deltaM):
#|                 return z_grsr
#|         # Emissionsklassen-Gate: Für bekannte Nicht-Δ(M)-Fälle (Jets/Pulsare/BL Lacs/AGN/Quasare)
#|         # verwenden wir GR*SR (z_grsr), da Δ(M)-Heuristik dort nicht passt.
#|         bad_for_deltaM = ("jet","psr","pulsar","bl_lac","3c","agn","quasar")
#|         if any((t in case) or (t in category) for t in bad_for_deltaM):
#|             return z_grsr
#|         if ("s-star" in category or "sgra" in case) and z_hint is not None:
#|             return z_seg_hint(row, z_sr, z_grsr)
#|         return z_seg_deltam(row, z_gr, z_sr, dmA, dmB, dmAlpha,
#|                             logM_min, logM_max, dataset_Lmin, dataset_Lmax)
#|     return z_grsr
#| 
#| # -----------------------------
#| # Evaluator (CSV-Datensatz)
#| # -----------------------------
#| def robust_mean(vec):
#|     if not vec: return None
#|     m = stats.median(vec)
#|     mad = stats.median([abs(x-m) for x in vec]) if len(vec) > 1 else 0.0
#|     filtered = [x for x in vec if (mad == 0 or abs(x-m) <= 5*mad)]
#|     return sum(filtered)/len(filtered) if filtered else m
#| 
#| def evaluate_dataset(df, prefer_z: bool, seg_mode: str, outdir: Path,
#|                      dmA: float, dmB: float, dmAlpha: float,
#|                      logM_min: Optional[float], logM_max: Optional[float],
#|                      make_plots: bool, top_k: int = 10,
#|                      use_emission_gate: bool = True):
#|     outdir.mkdir(parents=True, exist_ok=True)
#|     if pd is None:
#|         raise RuntimeError("pandas required for dataset evaluation. pip install pandas")
#| 
#|     # logM Bounds aus Datensatz
#|     Ms = []
#|     for _, r in df.iterrows():
#|         Msun = f2(r.get("M_solar"))
#|         if Msun and Msun > 0: Ms.append(D(str(Msun)) * M_sun)
#|     Lmin, Lmax = dm_norm_bounds(Ms) if Ms else (D('0'), D('1'))
#| 
#|     dbg_rows = []
#|     per_model_abs = {"seg": [], "gr": [], "sr": [], "grsr": []}
#|     ratios_vs_gr = []
#|     ratios_vs_grsr = []
#| 
#|     for idx, r in df.iterrows():
#|         row = {k: r[k] for k in df.columns}
#|         case = str(row.get("case", "")).strip() or f"ROW{idx}"
#| 
#|         # Beobachtung
#|         z_obs, z_src = observed_z(row, prefer_z=prefer_z)
#|         if z_obs is None or not math.isfinite(z_obs):
#|             dbg_rows.append({**row, "case": case, "z_source": z_src, "note": "no observed z"})
#|             continue
#| 
#|         # Geometrie / Geschwindigkeiten
#|         Msun = f2(row.get("M_solar"))
#|         M_c = (Msun or 0.0) * float(M_sun)
#|         a_m = f2(row.get("a_m"))
#|         e   = f2(row.get("e"))
#|         fdeg= f2(row.get("f_true_deg"))
#|         r_emit_m = f2(row.get("r_emit_m"))
#| 
#|         if r_emit_m is not None and math.isfinite(r_emit_m) and r_emit_m > 0:
#|             r_eff = r_emit_m
#|             r_note = "r_emit_m"
#|         elif all(v is not None for v in (a_m, e, fdeg)):
#|             r_eff = r_from_orbit(a_m, e, deg2rad(fdeg))
#|             r_note = "r(a,e,f)"
#|         else:
#|             r_eff, r_note = None, "no r"
#| 
#|         v_los = f2(row.get("v_los_mps")) or 0.0
#|         v_tot = f2(row.get("v_tot_mps"))
#| 
#|         # Baselines
#|         z_gr = z_gravitational(M_c, r_eff)
#|         z_sr = z_special_rel(v_tot, v_los)
#|         z_grsr = z_combined(z_gr, z_sr)
#|         # Segmented
#|         z_sg   = z_seg(row, seg_mode, z_gr, z_sr, z_grsr,
#|                        dmA, dmB, dmAlpha, logM_min, logM_max,
#|                        float(Lmin), float(Lmax),
#|                        use_emission_gate=use_emission_gate)
#| 
#|         dz_seg  = (z_obs - z_sg)    if math.isfinite(z_sg)   else float('nan')
#|         dz_gr   = (z_obs - z_gr)    if math.isfinite(z_gr)   else float('nan')
#|         dz_sr   = (z_obs - z_sr)    if math.isfinite(z_sr)   else float('nan')
#|         dz_grsr = (z_obs - z_grsr)  if math.isfinite(z_grsr) else float('nan')
#| 
#|         if math.isfinite(dz_seg):  per_model_abs["seg"].append(abs(dz_seg))
#|         if math.isfinite(dz_gr):   per_model_abs["gr"].append(abs(dz_gr))
#|         if math.isfinite(dz_sr):   per_model_abs["sr"].append(abs(dz_sr))
#|         if math.isfinite(dz_grsr): per_model_abs["grsr"].append(abs(dz_grsr))
#| 
#|         if math.isfinite(dz_gr) and abs(dz_gr) > 0 and math.isfinite(dz_seg):
#|             ratios_vs_gr.append((case, abs(dz_seg)/abs(dz_gr), abs(dz_seg), abs(dz_gr)))
#|         if math.isfinite(dz_grsr) and abs(dz_grsr) > 0 and math.isfinite(dz_seg):
#|             ratios_vs_grsr.append((case, abs(dz_seg)/abs(dz_grsr), abs(dz_seg), abs(dz_grsr)))
#| 
#|         dbg_rows.append({
#|             **row,
#|             "case": case,
#|             "z_obs": z_obs, "z_source": z_src,
#|             "r_eff_m": r_eff if (r_eff is not None and math.isfinite(r_eff)) else "",
#|             "r_note": r_note,
#|             "v_tot_mps": v_tot if (v_tot is not None and math.isfinite(v_tot)) else "",
#|             "v_los_mps": v_los if (v_los is not None and math.isfinite(v_los)) else "",
#|             "z_gr": z_gr if math.isfinite(z_gr) else "",
#|             "z_sr": z_sr if math.isfinite(z_sr) else "",
#|             "z_grsr": z_grsr if math.isfinite(z_grsr) else "",
#|             "z_seg": z_sg if math.isfinite(z_sg) else "",
#|             "dz_seg": dz_seg if math.isfinite(dz_seg) else "",
#|             "dz_gr": dz_gr if math.isfinite(dz_gr) else "",
#|             "dz_sr": dz_sr if math.isfinite(dz_sr) else "",
#|             "dz_grsr": dz_grsr if math.isfinite(dz_grsr) else "",
#|         })
#| 
#|     def summarize(vec):
#|         if not vec: return (None, None, None)
#|         return (stats.median(vec), robust_mean(vec), max(vec))
#| 
#|     med_seg, mean_seg, max_seg = summarize(per_model_abs["seg"])
#|     med_gr,  mean_gr,  max_gr  = summarize(per_model_abs["gr"])
#|     med_sr,  mean_sr,  max_sr  = summarize(per_model_abs["sr"])
#|     med_grsr,mean_grsr,max_grsr= summarize(per_model_abs["grsr"])
#| 
#|     outdir.mkdir(parents=True, exist_ok=True)
#|     dbg_path = outdir / "segspace_debug.csv"
#|     if pd is not None:
#|         pd.DataFrame(dbg_rows).to_csv(dbg_path, index=False)
#| 
#|     rep = textwrap.dedent(f"""
#|     =====================================================================
#|      SEGMENTED SPACETIME – DATASET EVALUATION
#|     =====================================================================
#|     Rows used: {len(dbg_rows)}
#|     seg-mode : {seg_mode}
#|     Δ(M)     : A={dmA}%  B={dmB}%  alpha={dmAlpha} [1/m]
#|     logM     : user=[{logM_min},{logM_max}]  dataset=[{float(Lmin):.3f},{float(Lmax):.3f}]
#| 
#|     Median/Mean/Max |Δz|
#|       Seg   : {med_seg!s:>10}  {mean_seg!s:>10}  {max_seg!s:>10}
#|       GR    : {med_gr!s:>10}  {mean_gr!s:>10}  {max_gr!s:>10}
#|       SR    : {med_sr!s:>10}  {mean_sr!s:>10}  {max_sr!s:>10}
#|       GR*SR : {med_grsr!s:>10}  {mean_grsr!s:>10}  {max_grsr!s:>10}
#| 
#|     Performance vs GR (Median): { (med_seg/med_gr if med_seg and med_gr else 'N/A') } ×
#|     Debug CSV  : {dbg_path}
#|     """).strip("\n")
#|     print(rep)
#| 
#|     ratio_path = outdir / "segspace_ratios.csv"
#|     with ratio_path.open("w", newline="", encoding="utf-8") as f:
#|         wr = csv.writer(f)
#|         wr.writerow(["case","ratio_vs_GR","dz_seg","dz_gr","ratio_vs_GR*SR","dz_grsr"])
#|         map_grsr = {c:(r,ds,dg) for c,r,ds,dg in ratios_vs_grsr}
#|         for c, r, ds, dg in ratios_vs_gr:
#|             r2, ds2, dg2 = map_grsr.get(c, (None,None,None))
#|             wr.writerow([c, f"{r:.6e}", f"{ds:.6e}", f"{dg:.6e}",
#|                          (f"{r2:.6e}" if r2 is not None else ""),
#|                          (f"{dg2:.6e}" if dg2 is not None else "")])
#|     print(f"Ratios-CSV         : {ratio_path}")
#| 
#|     def top_block(title, items, top_k):
#|         print("-------------------------------------------------------------")
#|         print(title)
#|         print("-------------------------------------------------------------")
#|         for case, r, ds, db in items[:top_k]:
#|             print(f"  {case:<24} ratio={r:8.3e}  | dz_seg={ds:8.3e}, dz_base={db:8.3e}")
#| 
#|     ratios_vs_gr.sort(key=lambda x: x[1])
#|     top_block("TOP – Seg vs GR (kleiner = besser):", ratios_vs_gr, top_k)
#|     ratios_vs_gr.sort(key=lambda x: x[1], reverse=True)
#|     top_block("Worst – Seg vs GR (größer = schlechter):", ratios_vs_gr, top_k)
#| 
#|     ratios_vs_grsr.sort(key=lambda x: x[1])
#|     top_block("TOP – Seg vs GR*SR (kleiner = besser):", ratios_vs_grsr, top_k)
#|     ratios_vs_grsr.sort(key=lambda x: x[1], reverse=True)
#|     top_block("Worst – Seg vs GR*SR (größer = schlechter):", ratios_vs_grsr, top_k)
#| 
#|     if make_plots:
#|         try:
#|             plt = _lazy_matplotlib()
#|             for key, title in [("seg","Seg"),("gr","GR"),("sr","SR"),("grsr","GR*SR")]:
#|                 vec = per_model_abs[key]
#|                 if not vec: continue
#|                 plt.figure(figsize=(8, 5))
#|                 plt.hist(vec, bins=24, alpha=0.75)
#|                 plt.xlabel("|Δz|"); plt.ylabel("Count")
#|                 plt.title(f"Residuals: {title} (Median = {stats.median(vec):.2e})")
#|                 plt.grid(True, alpha=0.3)
#|                 outp = outdir / f"hist_{key}.png"
#|                 plt.savefig(outp, dpi=140, bbox_inches="tight")
#|                 plt.close()
#|                 print(f"[INFO] Plot saved: {outp}")
#|         except Exception as ex:
#|             print(f"[WARN] plotting failed: {ex}")
#| 
#| # -----------------------------
#| # Bound-Energy & α (Frequenzen)
#| # -----------------------------
#| def bound_energy_rows(pairs: List[Tuple[D, D, str]]) -> List[dict]:
#|     rows = []
#|     for f_emit, f_obs, label in pairs:
#|         N_seg = f_emit / f_obs - D(1)
#|         E_gamma = h * f_emit
#|         alpha_local = (f_obs * h) / (D('9.1093837015e-31') * c**2)
#|         f_emit_back = (alpha_local * D('9.1093837015e-31') * c**2) / h
#|         z_gr = (f_emit - f_obs) / f_obs
#|         rel_error = abs(f_emit_back - f_emit) / f_emit
#|         rows.append({
#|             "label": label,
#|             "f_emit_Hz": f_emit,
#|             "f_obs_Hz": f_obs,
#|             "N_seg": N_seg,
#|             "E_gamma_J": E_gamma,
#|             "alpha_local": alpha_local,
#|             "z_gr": z_gr,
#|             "f_emit_back_calc_Hz": f_emit_back,
#|             "rel_error": rel_error
#|         })
#|     return rows
#| 
#| # -----------------------------
#| # Subcommands – Implementierungen
#| # -----------------------------
#| def cmd_pi_bridge(args):
#|     # Präzision (Subcommand-lokal erlaubt)
#|     getcontext().prec = int(args.prec)
#| 
#|     # π-Banner (für Protokoll/Reproduzierbarkeit)
#|     if args.pi_source == "chud":
#|         pi, ms = chudnovsky_pi(args.chud_terms, args.prec)
#|         pi_str = str(+pi)
#|         ms_str = f"{ms:.3f} ms"
#|     elif args.pi_source == "builtin":
#|         import math
#|         pi_str = repr(math.pi); ms_str = "0.000 ms"
#|     elif args.pi_source == "phi":
#|         pi_str = "phi-mode (π nicht genutzt)"; ms_str = "0.000 ms"
#|     else:
#|         raise ValueError("invalid --pi-source")
#| 
#|     print("\n=============================================================")
#|     print(" SEGMENTED SPACETIME – Δ(M) + CHUDNOVSKY‑π BRIDGE (Runner)")
#|     print("=============================================================")
#|     print(f"π ({args.pi_source})     : {pi_str[:100]}...")
#|     print(f"π compute time     : {ms_str}")
#| 
#|     # CSV wählen
#|     cand = [Path(args.csv)] if args.csv else []
#|     cand += [Path(x) for x in [
#|         "real_data_full.csv",
#|         "real_data_30_segmodel.csv",
#|         "real_data_30_segmodel_STRONG_NET.csv",
#|         "real_data_30_segmodel_LOCKED.csv",
#|     ]]
#|     csv_path = None
#|     for p in cand:
#|         if p and p.exists():
#|             csv_path = p; break
#|     if csv_path is None:
#|         print("[ERROR] no CSV found. Use --csv PATH.", file=sys.stderr)
#|         sys.exit(2)
#| 
#|     if pd is None:
#|         print("[ERROR] pandas required. pip install pandas", file=sys.stderr)
#|         sys.exit(3)
#| 
#|     df = pd.read_csv(csv_path)
#|     outdir = Path(args.out)
#|     outdir.mkdir(parents=True, exist_ok=True)
#| 
#|     evaluate_dataset(
#|         df,
#|         prefer_z=args.prefer_z,
#|         seg_mode=args.seg_mode,
#|         outdir=outdir,
#|         dmA=args.deltam_A,
#|         dmB=args.deltam_B,
#|         dmAlpha=args.deltam_alpha,
#|         logM_min=args.logM_min,
#|         logM_max=args.logM_max,
#|         make_plots=args.plots,
#|         top_k=args.top
#|     )
#|     print(f"Debug‑CSV          : {outdir/'segspace_debug.csv'}")
#|     print(f"Ratios‑CSV         : {outdir/'segspace_ratios.csv'}")
#| 
#| def cmd_mass_validate(args):
#|     getcontext().prec = int(args.prec)
#| 
#|     BASE = {
#|         'Elektron':        D('9.10938356e-31'),
#|         'Mond':            D('7.342e22'),
#|         'Erde':            D('5.97219e24'),
#|         'Sonne':           M_sun,
#|         'Sagittarius A*':  D('4.297e6') * M_sun,
#|     }
#|     if args.extra_csv and Path(args.extra_csv).exists():
#|         with open(args.extra_csv, newline='', encoding='utf-8') as f:
#|             for row in csv.DictReader(f):
#|                 try:
#|                     name = row['Objekt']
#|                     m_sun = D(str(row['M_true_Msun']))
#|                     BASE.setdefault(name, m_sun * M_sun)
#|                 except Exception:
#|                     continue
#| 
#|     masses = list(BASE.values())
#|     Lmin, Lmax = dm_norm_bounds(masses)
#| 
#|     results = []
#|     for name, M_true in BASE.items():
#|         r_s   = D(2)*G*M_true/c**2
#|         r_obs = BLC * r_s * (D(1) + dm_percent(M_true, Lmin, Lmax, D(str(args.deltam_A)), D(str(args.deltam_alpha)), D(str(args.deltam_B))) / D(100))
#|         M_rec = invert_mass(r_obs, M_true, Lmin, Lmax, D(str(args.deltam_A)), D(str(args.deltam_alpha)), D(str(args.deltam_B)))
#|         rel   = abs((M_rec - M_true)/M_true) * D(100)
#|         results.append((name, M_true, M_rec, rel))
#| 
#|     out_csv = Path(args.out or ".") / "segmented_spacetime_mass_validation_full.csv"
#|     out_csv.parent.mkdir(parents=True, exist_ok=True)
#|     with out_csv.open("w", newline="", encoding="utf-8") as f:
#|         w = csv.writer(f)
#|         w.writerow(["Objekt","M_true_kg","M_rec_kg","RelErr_%"])
#|         for name, Mt, Mr, err in results:
#|             w.writerow([name, f"{Mt:.6e}", f"{Mr:.6e}", f"{err:.3e}"])
#| 
#|     print("\n=============================================================")
#|     print(" SEGMENTED SPACETIME – MASS VALIDATION")
#|     print("=============================================================")
#|     print(f"{'Objekt':<20} {'M_true(kg)':>15} {'M_rec(kg)':>15} {'RelErr_%':>10}")
#|     print("-"*64)
#|     for name, Mt, Mr, err in results:
#|         print(f"{name:<20} {Mt:15.6e} {Mr:15.6e} {float(err):10.3e}")
#|     print(f"\nCSV export → {out_csv.resolve()}")
#| 
#| def cmd_bound_energy(args):
#|     getcontext().prec = int(args.prec)
#| 
#|     pairs: List[Tuple[D,D,str]] = []
#|     if args.pairs and Path(args.pairs).exists():
#|         # CSV mit Spalten: label,f_emit_Hz,f_obs_Hz
#|         with open(args.pairs, newline='', encoding='utf-8') as f:
#|             for row in csv.DictReader(f):
#|                 try:
#|                     label = row.get("label","?")
#|                     f_emit = D(str(row["f_emit_Hz"]))
#|                     f_obs  = D(str(row["f_obs_Hz"]))
#|                     pairs.append((f_emit, f_obs, label))
#|                 except Exception:
#|                     continue
#|     else:
#|         # Demo-Daten
#|         pairs = [
#|             (D("1.384e14"), D("1.383e14"), "S2 near Sgr A*"),
#|             (D("4.568e14"), D("4.567e14"), "Sirius B"),
#|             (D("4.759e14"), D("4.759e14"), "Sun line"),
#|             (D("3.482e18"), D("3.482e18"), "Pound–Rebka"),
#|             (D("4.570e14"), D("4.570e14"), "Earth lab"),
#|         ]
#| 
#|     rows = bound_energy_rows(pairs)
#|     outdir = Path(args.out or ".")
#|     outdir.mkdir(parents=True, exist_ok=True)
#|     out_csv = outdir / "bound_energy_results.csv"
#|     with out_csv.open("w", newline="", encoding="utf-8") as f:
#|         w = csv.writer(f)
#|         w.writerow(["label","f_emit_Hz","f_obs_Hz","N_seg","E_gamma_J","alpha_local","z_gr","f_emit_back_calc_Hz","rel_error"])
#|         for r in rows:
#|             w.writerow([
#|                 r["label"],
#|                 f"{r['f_emit_Hz']:.6E}",
#|                 f"{r['f_obs_Hz']:.6E}",
#|                 f"{r['N_seg']:.12E}",
#|                 f"{r['E_gamma_J']:.12E}",
#|                 f"{r['alpha_local']:.12E}",
#|                 f"{r['z_gr']:.12E}",
#|                 f"{r['f_emit_back_calc_Hz']:.6E}",
#|                 f"{r['rel_error']:.6E}",
#|             ])
#| 
#|     print("\n================================================================")
#|     print(" SEGMENTED SPACETIME – BOUND ENERGY / LOCAL α")
#|     print("================================================================")
#|     for r in rows:
#|         print(f"\n--- {r['label']} ---")
#|         print(f"f_emit    : {r['f_emit_Hz']:.6E} Hz")
#|         print(f"f_obs     : {r['f_obs_Hz']:.6E} Hz")
#|         print(f"N_seg     : {r['N_seg']:.12E}")
#|         print(f"E_gamma   : {r['E_gamma_J']:.12E} J")
#|         print(f"alpha_loc : {r['alpha_local']:.12E}")
#|         print(f"z_gr      : {r['z_gr']:.12E}")
#|         print(f"f_emit←α  : {r['f_emit_back_calc_Hz']:.6E} Hz")
#|         print(f"rel_error : {r['rel_error']:.6E}")
#| 
#|     print(f"\nCSV export → {out_csv.resolve()}")
#| 
#|     if args.plot:
#|         try:
#|             plt = _lazy_matplotlib()
#|             xs = list(range(1, len(rows)+1))
#|             errs = [float(r["rel_error"]) for r in rows]
#|             labels = [r["label"] for r in rows]
#|             plt.figure(figsize=(9,5))
#|             plt.plot(xs, errs, marker='o')
#|             for i, txt in enumerate(labels):
#|                 plt.annotate(txt, (xs[i], errs[i]), fontsize=8, xytext=(4,5), textcoords='offset points')
#|             plt.xlabel("Source ID")
#|             plt.ylabel("Relative Error of f_emit back-calc")
#|             plt.grid(True, alpha=0.4)
#|             out_png = outdir / "bound_energy_rel_error.png"
#|             plt.tight_layout(); plt.savefig(out_png, dpi=140)
#|             print(f"Plot saved → {out_png.resolve()}")
#|         except Exception as ex:
#|             print(f"[WARN] plotting failed: {ex}")
#| 
#| # -----------------------------
#| # CLI
#| # -----------------------------
#| def main():
#|     ap = argparse.ArgumentParser(description="SEGSPACE – All-in-One Toolkit")
#|     # Global --prec (falls VOR dem Subcommand verwendet wird)
#|     ap.add_argument("--prec", type=int, default=80, help="Decimal precision (global, default 80)")
#| 
#|     sub = ap.add_subparsers(dest="cmd", required=True)
#| 
#|     # π-Bridge / Evaluator
#|     ap_pi = sub.add_parser("pi-bridge", help="Run π-Bridge + Dataset Evaluation")
#|     ap_pi.add_argument("--prec", type=int, default=200, help="Decimal precision for this subcommand")
#|     ap_pi.add_argument("--csv", type=str, default=None, help="Input CSV (auto-detect fallback)")
#|     ap_pi.add_argument("--out", type=str, default="segspace_pi_bridge_out", help="Output directory")
#|     ap_pi.add_argument("--seg-mode", type=str, default="hybrid", choices=["hint","deltaM","hybrid","grsr"], help="Segment model")
#|     ap_pi.add_argument("--no-emission-gate", action="store_true", help="Disable emission-class gating (jets/pulsars/BL Lacs/AGN→GR*SR)")
#|     ap_pi.add_argument("--prefer-z", action="store_true", help="Prefer 'z' column over f_emit/f_obs")
#|     ap_pi.add_argument("--deltam-A", type=float, default=98.01, help="Δ(M) A in percent")
#|     ap_pi.add_argument("--deltam-B", type=float, default=1.96, help="Δ(M) B in percent")
#|     ap_pi.add_argument("--deltam-alpha", type=float, default=27177.0, help="Δ(M) alpha [1/m]")
#|     ap_pi.add_argument("--logM-min", type=float, default=None, help="Override min(log10 M)")
#|     ap_pi.add_argument("--logM-max", type=float, default=None, help="Override max(log10 M)")
#|     ap_pi.add_argument("--plots", action="store_true", help="Create residual histograms")
#|     ap_pi.add_argument("--top", type=int, default=10, help="Top K in Best/Worst lists")
#|     ap_pi.add_argument("--pi-source", type=str, default="chud", choices=["chud","builtin","phi"], help="π source for banner")
#|     ap_pi.add_argument("--chud-terms", type=int, default=16, help="Chudnovsky terms")
#|     ap_pi.set_defaults(func=cmd_pi_bridge)
#| 
#|     # Mass validate
#|     ap_mv = sub.add_parser("mass-validate", help="Validate Δ(M) mass inversion")
#|     ap_mv.add_argument("--prec", type=int, default=200, help="Decimal precision for this subcommand")
#|     ap_mv.add_argument("--extra-csv", type=str, default=None, help="Optional CSV with columns: Objekt,M_true_Msun")
#|     ap_mv.add_argument("--out", type=str, default="segspace_mass_out", help="Output directory")
#|     ap_mv.add_argument("--deltam-A", type=float, default=98.01)
#|     ap_mv.add_argument("--deltam-B", type=float, default=1.96)
#|     ap_mv.add_argument("--deltam-alpha", type=float, default=27177.0)
#|     ap_mv.set_defaults(func=cmd_mass_validate)
#| 
#|     # Bound energy
#|     ap_be = sub.add_parser("bound-energy", help="Compute bound energy & local α from frequency pairs")
#|     ap_be.add_argument("--prec", type=int, default=200, help="Decimal precision for this subcommand")
#|     ap_be.add_argument("--pairs", type=str, default=None, help="CSV: label,f_emit_Hz,f_obs_Hz")
#|     ap_be.add_argument("--out", type=str, default="bound_energy_out", help="Output directory")
#|     ap_be.add_argument("--plot", action="store_true", help="Plot relative error of f_emit back-calc")
#|     ap_be.set_defaults(func=cmd_bound_energy)
#| 
#|     args = ap.parse_args()
#| 
#|     # Falls --prec NUR global übergeben wurde (vor Subcommand): anwenden.
#|     getcontext().prec = int(getattr(args, "prec", 80))
#| 
#|     # Subcommand ausführen
#|     args.func(args)
#| 
#| if __name__ == "__main__":
#|     main()
