from __future__ import annotations

import json
from pathlib import Path

import numpy as np
import pandas as pd


def load_field(run_id: str, base: Path | None = None) -> pd.DataFrame:
    base = base or Path("models/cosmology")
    field_path = base / run_id / "ssz_field.parquet"
    if not field_path.exists():
        raise FileNotFoundError(
            f"\n\n"
            f"❌ MODEL FILE MISSING: {field_path}\n"
            f"\n"
            f"These model files are generated by running the SSZ pipeline.\n"
            f"They are not included in the repository (too large).\n"
            f"\n"
            f"🚀 To generate the required files:\n"
            f"   python run_all_ssz_terminal.py\n"
            f"\n"
            f"Or run the full test suite which includes pipeline execution:\n"
            f"   python run_full_suite.py\n"
            f"\n"
            f"⏱️  This will take ~5-10 minutes to generate all model files.\n"
        )
    return pd.read_parquet(field_path)


def test_segment_growth_is_monotonic(tmp_path: Path) -> None:
    """Test segment density grows monotonically with ring index
    
    Physical Meaning:
    Segment density should increase (or stay constant) as we move
    outward in rings. This ensures physical consistency of the
    segmented spacetime structure.
    """
    run_id = "2025-10-17_gaia_ssz_v1"
    df = load_field(run_id)
    growth = df.groupby("ring_id")["segment_density"].median().diff().dropna()
    
    print("\n" + "="*80)
    print("SEGMENT GROWTH MONOTONICITY TEST")
    print("="*80)
    print(f"Dataset: {run_id}")
    print(f"Number of rings: {df['ring_id'].nunique()}")
    
    if len(growth) == 0:
        # Only 1 ring → no growth to compute
        print(f"\nGrowth Statistics:")
        print(f"  Mean growth: N/A (only 1 ring)")
        print(f"  Min growth: N/A (only 1 ring)")
        print(f"  Max growth: N/A (only 1 ring)")
        print(f"  All non-negative: True (no inter-ring transitions)")
        print(f"\nPhysical Interpretation:")
        print(f"  • Single ring dataset: no growth to validate")
        print(f"  • Test passed by default (no violations possible)")
        print("="*80)
    else:
        # Multiple rings → compute growth statistics
        print(f"\nGrowth Statistics:")
        print(f"  Mean growth: {growth.mean():.6e}")
        print(f"  Min growth: {growth.min():.6e}")
        print(f"  Max growth: {growth.max():.6e}")
        print(f"  All non-negative: {(growth >= -1e-6).all()}")
        print(f"\nPhysical Interpretation:")
        print(f"  • Segment density increases outward (or remains stable)")
        print(f"  • Ensures consistent spacetime structure")
        print(f"  • No unphysical density drops between rings")
        print("="*80)
        
        assert (growth >= -1e-6).all(), "Segment density must be non-decreasing with ring index"


def test_natural_boundary_positive(tmp_path: Path) -> None:
    """Test natural boundary radii are positive
    
    Physical Meaning:
    Natural boundary represents the characteristic radius where
    segment effects become significant. Must be positive for
    physical validity.
    """
    run_id = "2025-10-17_gaia_ssz_v1"
    df = load_field(run_id)
    
    print("\n" + "="*80)
    print("NATURAL BOUNDARY POSITIVITY TEST")
    print("="*80)
    print(f"Dataset: {run_id}")
    print(f"\nNatural Boundary Statistics:")
    print(f"  Minimum: {df['natural_boundary'].min():.6e}")
    print(f"  Maximum: {df['natural_boundary'].max():.6e}")
    print(f"  Median: {df['natural_boundary'].median():.6e}")
    print(f"  All positive: {(df['natural_boundary'] > 0).all()}")
    print(f"\nPhysical Interpretation:")
    print(f"  • Positive boundary radii ensure physical segments")
    print(f"  • Defines scale where segmentation becomes important")
    print(f"  • Related to φ-based natural scales in spacetime")
    print("="*80)
    
    assert (df["natural_boundary"] > 0).all(), "Natural boundary radius must be positive"


def test_manifest_exists(tmp_path: Path) -> None:
    run_id = "2025-10-17_gaia_ssz_v1"
    manifest_path = Path("experiments") / run_id / "MANIFEST.json"
    assert manifest_path.exists(), f"Manifest missing: {manifest_path}"
    manifest = json.loads(manifest_path.read_text())
    required_keys = {"run_id", "inputs", "outputs", "environment"}
    assert required_keys.issubset(manifest), "Manifest missing required keys"


def test_spiral_index_bounds(tmp_path: Path) -> None:
    run_id = "2025-10-17_gaia_ssz_v1"
    df = load_field(run_id)
    assert "spiral_turn_index" in df.columns, "Spiral index missing from SSZ field"
    assert df["spiral_turn_index"].between(0, df["spiral_turn_index"].max()).all()


def test_solar_segments_non_empty(tmp_path: Path) -> None:
    run_id = "2025-10-17_gaia_ssz_v1"
    solar_path = Path("models/solar_system") / run_id / "solar_ssz.json"
    
    if not solar_path.exists():
        raise FileNotFoundError(
            f"\n\n"
            f"❌ SOLAR MODEL FILE MISSING: {solar_path}\n"
            f"\n"
            f"This file is generated by running the SSZ pipeline.\n"
            f"Model files are not included in the repository (generated data).\n"
            f"\n"
            f"🚀 To generate the required files:\n"
            f"   python run_all_ssz_terminal.py\n"
            f"\n"
            f"Or run the full test suite:\n"
            f"   python run_full_suite.py\n"
            f"\n"
            f"⏱️  Pipeline run takes ~5-10 minutes.\n"
        )
    
    payload = json.loads(solar_path.read_text())
    segments = payload.get("segments", [])
    assert segments, "Expected at least one solar segment after local selection"


def test_segment_density_positive(tmp_path: Path) -> None:
    """Test segment densities are strictly positive
    
    Physical Meaning:
    Segment density must be positive everywhere for physical
    consistency. Represents the local strength of spacetime
    segmentation.
    """
    run_id = "2025-10-17_gaia_ssz_v1"
    df = load_field(run_id)
    
    print("\n" + "="*80)
    print("SEGMENT DENSITY POSITIVITY TEST")
    print("="*80)
    print(f"Dataset: {run_id}")
    print(f"Total segments: {len(df)}")
    print(f"\nDensity Statistics:")
    print(f"  Minimum: {df['segment_density'].min():.6e}")
    print(f"  Maximum: {df['segment_density'].max():.6e}")
    print(f"  Mean: {df['segment_density'].mean():.6e}")
    print(f"  Std Dev: {df['segment_density'].std():.6e}")
    print(f"  All positive: {(df['segment_density'] > 0).all()}")
    print(f"\nPhysical Interpretation:")
    print(f"  • Positive density ensures physical spacetime segments")
    print(f"  • Zero density would indicate classical (non-SSZ) limit")
    print(f"  • Density distribution shows segment field strength")
    print("="*80)
    
    assert (df["segment_density"] > 0).all(), "Segment densities must be strictly positive"
