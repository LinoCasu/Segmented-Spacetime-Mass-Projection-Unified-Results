#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Test suite for the four key predictions of Segmented Spacetime Theory:
1. Finite Horizon Area
2. Information Preservation
3. Singularity Resolution
4. Natural Hawking Radiation

© 2025 Carmen Wrede, Lino Casu
Licensed under the ANTI-CAPITALIST SOFTWARE LICENSE v1.4
"""
from __future__ import annotations

import os
import sys
from pathlib import Path

import numpy as np
import pandas as pd

# UTF-8 for subprocess safety (Windows compatibility)
os.environ['PYTHONIOENCODING'] = 'utf-8:replace'

# Fix Windows console encoding for Unicode output (φ, ≈, ✅, ❌, etc.)
if sys.platform.startswith('win'):
    try:
        sys.stdout.reconfigure(encoding='utf-8', errors='replace')
        sys.stderr.reconfigure(encoding='utf-8', errors='replace')
    except AttributeError:
        # Fallback for older Python versions
        import codecs
        sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'replace')
        sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'replace')

# Golden ratio constant
PHI = (1 + np.sqrt(5)) / 2


def load_phi_debug_data(base_path: Path | None = None) -> pd.DataFrame:
    """Load phi_step_debug_full.csv with n_round data"""
    if base_path is None:
        base_path = Path("out")
    
    data_path = base_path / "phi_step_debug_full.csv"
    
    if not data_path.exists():
        raise FileNotFoundError(
            f"\n\n"
            f"❌ DATA FILE MISSING: {data_path}\n"
            f"\n"
            f"This file is generated by running the SSZ analysis pipeline.\n"
            f"\n"
            f"🚀 To generate the required files:\n"
            f"   python run_all_ssz_terminal.py\n"
            f"\n"
            f"Or run the full test suite:\n"
            f"   python run_full_suite.py\n"
            f"\n"
            f"⏱️  Pipeline run takes ~5-10 minutes.\n"
        )
    
    return pd.read_csv(data_path)


def load_enhanced_debug_data(base_path: Path | None = None) -> pd.DataFrame:
    """Load _enhanced_debug.csv with redshift decomposition"""
    if base_path is None:
        base_path = Path("out")
    
    data_path = base_path / "_enhanced_debug.csv"
    
    if not data_path.exists():
        raise FileNotFoundError(
            f"\n\n"
            f"❌ DATA FILE MISSING: {data_path}\n"
            f"\n"
            f"Generate via: python run_all_ssz_terminal.py\n"
        )
    
    return pd.read_csv(data_path)


def test_finite_horizon_area(tmp_path: Path) -> None:
    """Test Prediction 1: Finite Horizon Area at r_φ
    
    Physical Meaning:
    SSZ predicts a finite horizon area at r_φ where n_round ≈ 4φ.
    Unlike GR black holes (point singularity), SSZ has a finite
    characteristic radius with well-defined area A_H = 4π r_φ².
    """
    df = load_phi_debug_data()
    
    # Target: n_round ≈ 4φ ≈ 6.472
    target_n = 4 * PHI
    tolerance = 0.5  # Start with 0.5, expand if needed
    
    # Find horizon candidates
    mask = np.abs(df['n_round'] - target_n) < tolerance
    horizon_candidates = df[mask]
    
    # Fallback: If no candidates, take closest 5
    if len(horizon_candidates) == 0:
        df_sorted = df.iloc[np.argsort(np.abs(df['n_round'] - target_n))]
        horizon_candidates = df_sorted.head(5)
        fallback = True
    else:
        fallback = False
    
    # Estimate r_φ as median of r_emit_m
    r_phi = horizon_candidates['r_emit_m'].median()
    
    # Calculate horizon area
    A_H = 4 * np.pi * r_phi**2
    
    print("\n" + "="*80)
    print("PREDICTION 1: FINITE HORIZON AREA")
    print("="*80)
    print(f"Target n_round: 4φ ≈ {target_n:.4f}")
    print(f"Tolerance: ±{tolerance}")
    print(f"Candidates found: {len(horizon_candidates)}")
    print(f"{'(Fallback: 5 closest points)' if fallback else '(Direct match)'}")
    print(f"\nHorizon Radius:")
    print(f"  r_φ (median) = {r_phi:.4e} m")
    print(f"  r_φ (mean)   = {horizon_candidates['r_emit_m'].mean():.4e} m")
    print(f"  r_φ (std)    = {horizon_candidates['r_emit_m'].std():.4e} m")
    print(f"\nHorizon Area:")
    print(f"  A_H = 4π r_φ² = {A_H:.4e} m²")
    print(f"\nPhysical Interpretation:")
    print(f"  • Finite horizon radius (not point singularity)")
    print(f"  • Well-defined surface area at characteristic scale")
    print(f"  • φ-based geometric structure (4φ spiral turns)")
    print("="*80)
    
    # Assertions
    assert r_phi > 0, "Horizon radius must be positive"
    assert np.isfinite(A_H), "Horizon area must be finite"
    assert A_H > 0, "Horizon area must be positive"


def test_information_preservation(tmp_path: Path) -> None:
    """Test Prediction 2: Information is Preserved
    
    Physical Meaning:
    SSZ predicts invertible mapping between emitted and observed frequencies.
    For each source, the Jacobian ∂ν_obs/∂ν_emit should be non-zero,
    allowing reconstruction ν_emit → ν_obs → ν_emit,recon with small error.
    """
    df = load_phi_debug_data()
    
    # Group by source
    sources = df['source'].unique()
    
    results = []
    for source in sources:
        source_data = df[df['source'] == source].copy()
        
        # Need at least 3 points for meaningful test
        if len(source_data) < 3:
            continue
        
        # Sort by f_emit_Hz
        source_data = source_data.sort_values('f_emit_Hz')
        
        # Check monotonicity (proxy for invertibility)
        f_emit = source_data['f_emit_Hz'].values
        f_obs = source_data['f_obs_Hz'].values
        
        # Compute local Jacobian (finite differences)
        if len(f_emit) >= 2:
            df_obs = np.diff(f_obs)
            df_emit = np.diff(f_emit)
            
            # Avoid division by zero
            mask = np.abs(df_emit) > 1e-20
            if np.any(mask):
                jacobian = df_obs[mask] / df_emit[mask]
                jacobian_mean = np.mean(np.abs(jacobian))
                jacobian_nonzero = np.all(np.abs(jacobian) > 1e-10)
                
                # Test monotonicity
                is_monotonic = np.all(df_obs[mask] * df_emit[mask] > 0)
                
                results.append({
                    'source': source,
                    'n_points': len(source_data),
                    'jacobian_mean': jacobian_mean,
                    'jacobian_nonzero': jacobian_nonzero,
                    'is_monotonic': is_monotonic
                })
    
    results_df = pd.DataFrame(results)
    
    # Statistics
    n_sources = len(results_df)
    
    if n_sources > 0:
        n_invertible = results_df['jacobian_nonzero'].sum()
        n_monotonic = results_df['is_monotonic'].sum()
    else:
        n_invertible = 0
        n_monotonic = 0
    
    print("\n" + "="*80)
    print("PREDICTION 2: INFORMATION PRESERVATION")
    print("="*80)
    print(f"Total sources in dataset: {len(sources)}")
    print(f"Sources with ≥3 data points: {n_sources}")
    
    if n_sources > 0:
        print(f"\nInvertibility Metrics:")
        print(f"  Non-zero Jacobian: {n_invertible}/{n_sources} ({100*n_invertible/max(n_sources,1):.1f}%)")
        print(f"  Monotonic mapping: {n_monotonic}/{n_sources} ({100*n_monotonic/max(n_sources,1):.1f}%)")
        print(f"  Mean |Jacobian|:   {results_df['jacobian_mean'].mean():.4e}")
        print(f"  Median |Jacobian|: {results_df['jacobian_mean'].median():.4e}")
        print(f"\nPhysical Interpretation:")
        print(f"  • Non-zero Jacobian → locally invertible mapping")
        print(f"  • Monotonic → globally invertible per source")
        print(f"  • Information can be recovered from observations")
        print(f"  • No information loss at horizon (unlike GR black holes)")
    else:
        print(f"\n⚠️  Insufficient data: No sources with ≥3 points for Jacobian test")
        print(f"    This test requires multiple frequency measurements per source")
        print(f"\nPhysical Interpretation:")
        print(f"  • Test requires orbital motion data (multiple observations)")
        print(f"  • Single-point measurements cannot test invertibility")
        print(f"  • Consider collecting time-series data for each source")
    
    print("="*80)
    
    # At least some sources should be invertible (if data exists)
    if n_sources > 0:
        assert n_invertible > 0, "At least some sources should have invertible mappings"


def test_singularity_resolution(tmp_path: Path) -> None:
    """Test Prediction 3: Singularity is Resolved
    
    Physical Meaning:
    SSZ predicts no divergences as r → 0. Residuals and physical
    quantities remain finite at small radii. This is tested by
    examining the behavior at minimum r_emit_m values.
    """
    df = load_phi_debug_data()
    
    # Sort by r_emit_m
    df_sorted = df.sort_values('r_emit_m')
    
    # Examine smallest radii (bottom 10%)
    n_small = max(10, len(df) // 10)
    df_small = df_sorted.head(n_small)
    
    # Check for divergences
    residuals = df_small['residual'].values
    abs_residuals = df_small['abs_residual'].values
    
    max_residual = np.max(np.abs(residuals))
    mean_residual = np.mean(np.abs(residuals))
    
    has_nan = np.any(np.isnan(residuals))
    has_inf = np.any(np.isinf(residuals))
    
    print("\n" + "="*80)
    print("PREDICTION 3: SINGULARITY RESOLUTION")
    print("="*80)
    print(f"Total data points: {len(df)}")
    print(f"Smallest radii examined: {n_small} points")
    print(f"\nRadius range (smallest {n_small}):")
    print(f"  r_min = {df_small['r_emit_m'].min():.4e} m")
    print(f"  r_max = {df_small['r_emit_m'].max():.4e} m")
    print(f"\nResidual Statistics at Small Radii:")
    print(f"  Max |residual|  = {max_residual:.4e}")
    print(f"  Mean |residual| = {mean_residual:.4e}")
    print(f"  Contains NaN: {has_nan}")
    print(f"  Contains Inf: {has_inf}")
    print(f"\nPhysical Interpretation:")
    print(f"  • Finite residuals → no divergence at small r")
    print(f"  • Segmentation prevents singularity formation")
    print(f"  • Physical quantities remain bounded")
    print(f"  • Contrast with GR: r → 0 causes divergence")
    print("="*80)
    
    # Assertions
    assert not has_nan, "Residuals must not contain NaN (no computational breakdown)"
    assert not has_inf, "Residuals must not contain Inf (no divergence)"
    assert max_residual < 1.0, "Residuals should remain bounded (< 1.0)"


def test_hawking_radiation_proxy(tmp_path: Path) -> None:
    """Test Prediction 4: Natural Hawking Radiation via κ_seg
    
    Physical Meaning:
    SSZ predicts a surface gravity analog κ_seg = d/dr ln(χ) at r_φ,
    where χ = 1/(1+z). This should yield a characteristic temperature
    scale T_seg ∝ |κ_seg| analogous to Hawking radiation, but arising
    naturally from the segmented structure.
    """
    df_phi = load_phi_debug_data()
    df_enhanced = load_enhanced_debug_data()
    
    # Find r_φ (same as in test 1)
    target_n = 4 * PHI
    tolerance = 0.5
    mask = np.abs(df_phi['n_round'] - target_n) < tolerance
    horizon_candidates = df_phi[mask]
    
    if len(horizon_candidates) == 0:
        df_sorted = df_phi.iloc[np.argsort(np.abs(df_phi['n_round'] - target_n))]
        horizon_candidates = df_sorted.head(5)
    
    r_phi = horizon_candidates['r_emit_m'].median()
    
    # Compute χ = 1/(1+z) from enhanced data
    # Use z_obs for observed redshift
    df_enhanced['chi'] = 1.0 / (1.0 + df_enhanced['z_obs'])
    
    # Find points near r_φ (within ±5%)
    r_window = 0.05 * r_phi
    mask_window = np.abs(df_enhanced['r_emit_m'] - r_phi) < r_window
    df_window = df_enhanced[mask_window]
    
    if len(df_window) < 3:
        # Fallback: nearest 7 points
        df_sorted = df_enhanced.iloc[np.argsort(np.abs(df_enhanced['r_emit_m'] - r_phi))]
        df_window = df_sorted.head(7)
    
    # Sort by radius
    df_window = df_window.sort_values('r_emit_m')
    
    # Compute κ_seg = d/dr ln(χ)
    r = df_window['r_emit_m'].values
    chi = df_window['chi'].values
    
    # Remove any invalid values
    valid = np.isfinite(chi) & (chi > 0) & np.isfinite(r)
    r = r[valid]
    chi = chi[valid]
    
    if len(r) >= 2:
        ln_chi = np.log(chi)
        
        # Finite difference
        d_ln_chi = np.diff(ln_chi)
        d_r = np.diff(r)
        
        # Avoid division by zero
        mask_nonzero = np.abs(d_r) > 1e-10
        if np.any(mask_nonzero):
            kappa_seg = d_ln_chi[mask_nonzero] / d_r[mask_nonzero]
            kappa_median = np.median(np.abs(kappa_seg))
            kappa_mean = np.mean(np.abs(kappa_seg))
            
            # Hawking temperature proxy (order of magnitude)
            # T_hawking ∝ ħ κ / (2π k_B c)
            # For order of magnitude: just use |κ|
            h_bar = 1.054571817e-34  # J·s
            k_B = 1.380649e-23  # J/K
            c = 299792458  # m/s
            
            T_proxy = (h_bar * kappa_median) / (2 * np.pi * k_B * c)
            
            print("\n" + "="*80)
            print("PREDICTION 4: NATURAL HAWKING RADIATION")
            print("="*80)
            print(f"Horizon radius r_φ: {r_phi:.4e} m")
            print(f"Analysis window: ±{100*0.05:.0f}% around r_φ")
            print(f"Points in window: {len(df_window)}")
            print(f"\nSurface Gravity Proxy κ_seg:")
            print(f"  κ_seg (median) = {kappa_median:.4e} m⁻¹")
            print(f"  κ_seg (mean)   = {kappa_mean:.4e} m⁻¹")
            print(f"\nTemperature Proxy:")
            print(f"  T_seg ∝ |κ_seg| ≈ {T_proxy:.4e} K")
            print(f"  (order of magnitude estimate)")
            print(f"\nPhysical Interpretation:")
            print(f"  • κ_seg emerges naturally from segment structure")
            print(f"  • Analogous to surface gravity at horizon")
            print(f"  • Predicts thermal spectrum T ∝ κ_seg")
            print(f"  • No singularity needed (unlike Hawking derivation)")
            print("="*80)
            
            # Assertions
            assert np.isfinite(kappa_median), "Surface gravity must be finite"
            assert kappa_median > 0, "Surface gravity magnitude must be positive"
        else:
            print("\n⚠️  Insufficient data for κ_seg calculation (denominator too small)")
    else:
        print("\n⚠️  Insufficient data points for κ_seg calculation")


# Main execution for standalone testing
if __name__ == "__main__":
    import sys
    from pathlib import Path
    
    print("="*80)
    print("SSZ THEORY: FOUR KEY PREDICTIONS TEST SUITE")
    print("="*80)
    
    tmp = Path(".")
    
    try:
        test_finite_horizon_area(tmp)
        print("\n✅ Test 1 PASSED: Finite Horizon Area\n")
    except Exception as e:
        print(f"\n❌ Test 1 FAILED: {e}\n")
        sys.exit(1)
    
    try:
        test_information_preservation(tmp)
        print("\n✅ Test 2 PASSED: Information Preservation\n")
    except Exception as e:
        print(f"\n❌ Test 2 FAILED: {e}\n")
        sys.exit(1)
    
    try:
        test_singularity_resolution(tmp)
        print("\n✅ Test 3 PASSED: Singularity Resolution\n")
    except Exception as e:
        print(f"\n❌ Test 3 FAILED: {e}\n")
        sys.exit(1)
    
    try:
        test_hawking_radiation_proxy(tmp)
        print("\n✅ Test 4 PASSED: Hawking Radiation Proxy\n")
    except Exception as e:
        print(f"\n❌ Test 4 FAILED: {e}\n")
        sys.exit(1)
    
    print("="*80)
    print("ALL PREDICTION TESTS PASSED ✅")
    print("="*80)
